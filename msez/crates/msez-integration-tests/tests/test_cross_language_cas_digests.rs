//! # Cross-Language CAS Digest Test
//!
//! Loads fixture data generated by Python `tools/lawpack.py:jcs_canonicalize()`
//! and `tools/artifacts.py` CAS conventions, then verifies that the Rust
//! `msez_crypto::cas::ContentAddressedStore` produces identical digests and
//! storage paths.
//!
//! ## Fixture Source
//!
//! `tests/fixtures/cas_digests.json` — generated by computing canonical bytes
//! and SHA-256 digests through the Python pipeline for representative artifact
//! types (receipt, vc, lawpack, ruleset, transition-types).
//!
//! ## CAS Path Convention
//!
//! `dist/artifacts/{type}/{digest}.json` — the artifact type directory and
//! digest-based filename must be identical across Python and Rust.

use msez_core::{sha256_digest, CanonicalBytes};
use msez_crypto::cas::{ArtifactRef, ContentAddressedStore};
use serde::Deserialize;
use serde_json::Value;

const FIXTURE_PATH: &str = "tests/fixtures/cas_digests.json";

#[derive(Debug, Deserialize)]
struct CasFixtures {
    artifacts: Vec<ArtifactFixture>,
}

#[derive(Debug, Deserialize)]
struct ArtifactFixture {
    artifact_type: String,
    input: Value,
    canonical_utf8: String,
    sha256_digest: String,
    expected_path: String,
}

fn load_fixtures() -> CasFixtures {
    let manifest_dir = std::path::Path::new(env!("CARGO_MANIFEST_DIR"));
    let repo_root = manifest_dir
        .parent()
        .expect("crates/")
        .parent()
        .expect("msez/")
        .parent()
        .expect("repo root");
    let fixture_path = repo_root.join(FIXTURE_PATH);
    let content = std::fs::read_to_string(&fixture_path).unwrap_or_else(|e| {
        panic!(
            "Failed to read fixture file at {}: {e}",
            fixture_path.display()
        )
    });
    serde_json::from_str(&content).expect("Failed to parse fixture JSON")
}

/// Verify that Rust canonical bytes match Python canonical bytes for all
/// CAS artifact fixtures.
#[test]
fn cas_canonical_bytes_match_python() {
    let fixtures = load_fixtures();

    for art in &fixtures.artifacts {
        let canonical = CanonicalBytes::new(&art.input).unwrap_or_else(|e| {
            panic!(
                "CanonicalBytes::new() failed for artifact type '{}': {e}",
                art.artifact_type
            )
        });
        let rust_utf8 = std::str::from_utf8(canonical.as_bytes()).unwrap();
        assert_eq!(
            rust_utf8, art.canonical_utf8,
            "Canonical mismatch for artifact type '{}': Rust={rust_utf8}, Python={}",
            art.artifact_type, art.canonical_utf8
        );
    }
}

/// Verify that Rust SHA-256 digests match Python digests for all CAS
/// artifact fixtures.
#[test]
fn cas_digests_match_python() {
    let fixtures = load_fixtures();

    for art in &fixtures.artifacts {
        let canonical = CanonicalBytes::new(&art.input).unwrap();
        let digest = sha256_digest(&canonical);
        assert_eq!(
            digest.to_hex(),
            art.sha256_digest,
            "Digest mismatch for artifact type '{}':\n  Rust:   {}\n  Python: {}",
            art.artifact_type,
            digest.to_hex(),
            art.sha256_digest
        );
    }
}

/// Verify that the CAS storage path matches the Python convention:
/// `{base_dir}/{artifact_type}/{digest}.json`.
#[test]
fn cas_path_convention_matches_python() {
    let fixtures = load_fixtures();

    for art in &fixtures.artifacts {
        let canonical = CanonicalBytes::new(&art.input).unwrap();
        let digest = sha256_digest(&canonical);

        let artifact_ref = ArtifactRef::new(&art.artifact_type, digest).unwrap();
        let path = artifact_ref.path_in(std::path::Path::new("dist/artifacts"));

        // Convert to forward-slash path for comparison with the Python fixture.
        let path_str = path
            .to_str()
            .expect("path should be valid UTF-8")
            .replace('\\', "/");
        assert_eq!(
            path_str, art.expected_path,
            "CAS path mismatch for artifact type '{}':\n  Rust:   {path_str}\n  Python: {}",
            art.artifact_type, art.expected_path
        );
    }
}

/// Verify CAS store + resolve roundtrip produces correct digests.
#[test]
fn cas_store_resolve_roundtrip_with_fixture_data() {
    let fixtures = load_fixtures();
    let dir = tempfile::tempdir().unwrap();
    let cas = ContentAddressedStore::new(dir.path());

    for art in &fixtures.artifacts {
        // Store via the Rust CAS.
        let artifact_ref = cas.store(&art.artifact_type, &art.input).unwrap_or_else(|e| {
            panic!(
                "CAS store failed for artifact type '{}': {e}",
                art.artifact_type
            )
        });

        // Verify the stored digest matches the Python fixture.
        assert_eq!(
            artifact_ref.digest.to_hex(),
            art.sha256_digest,
            "Stored digest mismatch for artifact type '{}'",
            art.artifact_type
        );

        // Resolve and verify content integrity.
        let resolved = cas
            .resolve(&art.artifact_type, &artifact_ref.digest)
            .unwrap()
            .expect("artifact should exist after store");

        // The resolved bytes should be the canonical form.
        let resolved_str = std::str::from_utf8(&resolved).unwrap();
        assert_eq!(
            resolved_str, art.canonical_utf8,
            "Resolved content mismatch for artifact type '{}'",
            art.artifact_type
        );
    }
}

/// Verify that different artifact types with the same data produce
/// the same digest (CAS is content-addressed, not type-addressed).
#[test]
fn cas_same_content_same_digest() {
    let fixtures = load_fixtures();
    let dir = tempfile::tempdir().unwrap();
    let cas = ContentAddressedStore::new(dir.path());

    // Take the first artifact and store it under a different type.
    let art = &fixtures.artifacts[0];
    let ref1 = cas.store(&art.artifact_type, &art.input).unwrap();
    let ref2 = cas.store("test-duplicate", &art.input).unwrap();

    assert_eq!(
        ref1.digest.to_hex(),
        ref2.digest.to_hex(),
        "Same data should produce same digest regardless of artifact type"
    );
}

/// Verify store idempotency: storing the same data twice should not fail
/// and should return the same digest.
#[test]
fn cas_store_idempotent_with_fixture_data() {
    let fixtures = load_fixtures();
    let dir = tempfile::tempdir().unwrap();
    let cas = ContentAddressedStore::new(dir.path());

    for art in &fixtures.artifacts {
        let ref1 = cas.store(&art.artifact_type, &art.input).unwrap();
        let ref2 = cas.store(&art.artifact_type, &art.input).unwrap();

        assert_eq!(
            ref1.digest.to_hex(),
            ref2.digest.to_hex(),
            "Idempotent store should produce same digest for '{}'",
            art.artifact_type
        );
    }
}
