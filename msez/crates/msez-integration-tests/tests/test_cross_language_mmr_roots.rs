//! # Cross-Language MMR Roots Test
//!
//! Loads fixture data generated by Python `tools/mmr.py` and verifies that
//! the Rust `msez_crypto::mmr` module produces identical roots, peaks, leaf
//! hashes, and node hashes at every step.
//!
//! ## Fixture Source
//!
//! `tests/fixtures/mmr_roots.json` â€” generated by running the Python MMR
//! implementation with `SHA256("receipt-{i}".encode())` as leaf data for
//! i in 1..17.
//!
//! ## Domain Separation
//!
//! - Leaf: `SHA256(0x00 || leaf_bytes)` where leaf_bytes is 32 raw bytes
//!   decoded from the next_root hex digest.
//! - Node: `SHA256(0x01 || left_hash_bytes || right_hash_bytes)`.

use msez_crypto::mmr::{
    bag_peaks, build_inclusion_proof, build_peaks, mmr_leaf_hash, mmr_node_hash,
    mmr_root_from_next_roots, verify_inclusion_proof, MerkleMountainRange,
};
use serde::Deserialize;
use sha2::{Digest, Sha256};

const FIXTURE_PATH: &str = "tests/fixtures/mmr_roots.json";

#[derive(Debug, Deserialize)]
struct MmrFixtures {
    next_roots: Vec<String>,
    leaf_hashes: Vec<String>,
    leaf_hash_vectors: Vec<LeafHashVector>,
    node_hash_vector: NodeHashVector,
    incremental_roots: Vec<IncrementalRoot>,
}

#[derive(Debug, Deserialize)]
struct LeafHashVector {
    input_next_root: String,
    leaf_hash: String,
}

#[derive(Debug, Deserialize)]
struct NodeHashVector {
    left: String,
    right: String,
    result: String,
}

#[derive(Debug, Deserialize)]
struct IncrementalRoot {
    size: usize,
    root: String,
    peaks: Vec<PeakJson>,
}

#[derive(Debug, Deserialize)]
struct PeakJson {
    height: usize,
    hash: String,
}

fn load_fixtures() -> MmrFixtures {
    let manifest_dir = std::path::Path::new(env!("CARGO_MANIFEST_DIR"));
    let repo_root = manifest_dir
        .parent()
        .expect("crates/")
        .parent()
        .expect("msez/")
        .parent()
        .expect("repo root");
    let fixture_path = repo_root.join(FIXTURE_PATH);
    let content = std::fs::read_to_string(&fixture_path).unwrap_or_else(|e| {
        panic!(
            "Failed to read fixture file at {}: {e}",
            fixture_path.display()
        )
    });
    serde_json::from_str(&content).expect("Failed to parse fixture JSON")
}

/// Helper matching Python `SHA256("receipt-{i}".encode())`.
fn receipt_hash(i: usize) -> String {
    let data = format!("receipt-{i}");
    let result = Sha256::digest(data.as_bytes());
    result.iter().map(|b| format!("{b:02x}")).collect()
}

/// Verify that our receipt hash generation matches the Python fixture's
/// next_roots exactly.
#[test]
fn next_roots_match_python() {
    let fixtures = load_fixtures();

    for (i, expected) in fixtures.next_roots.iter().enumerate() {
        let actual = receipt_hash(i + 1);
        assert_eq!(&actual, expected, "next_root mismatch at receipt-{}", i + 1);
    }
}

/// Verify leaf hash computation matches Python fixtures.
#[test]
fn leaf_hashes_match_python() {
    let fixtures = load_fixtures();

    for vector in &fixtures.leaf_hash_vectors {
        let rust_lh = mmr_leaf_hash(&vector.input_next_root).unwrap();
        assert_eq!(
            rust_lh, vector.leaf_hash,
            "Leaf hash mismatch for input {}",
            vector.input_next_root
        );
    }
}

/// Verify all 17 leaf hashes match the Python fixture.
#[test]
fn all_leaf_hashes_match_python() {
    let fixtures = load_fixtures();
    assert_eq!(fixtures.next_roots.len(), 17);
    assert_eq!(fixtures.leaf_hashes.len(), 17);

    for (i, (nr, expected_lh)) in fixtures
        .next_roots
        .iter()
        .zip(fixtures.leaf_hashes.iter())
        .enumerate()
    {
        let rust_lh = mmr_leaf_hash(nr).unwrap();
        assert_eq!(
            &rust_lh,
            expected_lh,
            "Leaf hash mismatch at index {i} (receipt-{})",
            i + 1
        );
    }
}

/// Verify node hash computation matches the Python fixture.
#[test]
fn node_hash_matches_python() {
    let fixtures = load_fixtures();
    let v = &fixtures.node_hash_vector;

    let rust_nh = mmr_node_hash(&v.left, &v.right).unwrap();
    assert_eq!(
        rust_nh, v.result,
        "Node hash mismatch:\n  left:  {}\n  right: {}\n  expected: {}\n  got:      {rust_nh}",
        v.left, v.right, v.result
    );
}

/// Verify incremental MMR roots match the Python fixture at each append step.
///
/// This is the core cross-language equivalence test: we build the MMR one
/// leaf at a time and verify the root matches the Python fixture after
/// each append.
#[test]
fn incremental_roots_match_python() {
    let fixtures = load_fixtures();

    for expected in &fixtures.incremental_roots {
        let next_roots: Vec<String> = fixtures.next_roots[..expected.size].to_vec();
        let info = mmr_root_from_next_roots(&next_roots).unwrap();

        assert_eq!(
            info.root, expected.root,
            "Root mismatch at size={}: Rust={}, Python={}",
            expected.size, info.root, expected.root
        );
        assert_eq!(
            info.peaks.len(),
            expected.peaks.len(),
            "Peak count mismatch at size={}",
            expected.size
        );

        for (i, (rust_peak, py_peak)) in info.peaks.iter().zip(expected.peaks.iter()).enumerate() {
            assert_eq!(
                rust_peak.height, py_peak.height,
                "Peak height mismatch at size={}, peak index={i}",
                expected.size
            );
            assert_eq!(
                rust_peak.hash, py_peak.hash,
                "Peak hash mismatch at size={}, peak index={i}",
                expected.size
            );
        }
    }
}

/// Verify the stateful MerkleMountainRange wrapper produces identical
/// roots as the functional API and Python fixture at sizes 1, 9, and 17.
#[test]
fn stateful_mmr_matches_python_fixture() {
    let fixtures = load_fixtures();
    let mut mmr = MerkleMountainRange::new();

    // Build a lookup map from size -> expected root.
    let expected_by_size: std::collections::HashMap<usize, &str> = fixtures
        .incremental_roots
        .iter()
        .map(|r| (r.size, r.root.as_str()))
        .collect();

    for (i, nr) in fixtures.next_roots.iter().enumerate() {
        mmr.append(nr).unwrap();
        let size = i + 1;

        if let Some(&expected_root) = expected_by_size.get(&size) {
            let rust_root = mmr.root().unwrap();
            assert_eq!(
                rust_root, expected_root,
                "Stateful MMR root mismatch at size={size}"
            );
        }
    }
}

/// Verify that build_peaks + bag_peaks matches mmr_root_from_next_roots
/// for the full 17-receipt sequence.
#[test]
fn build_peaks_bag_peaks_matches_python_17() {
    let fixtures = load_fixtures();
    let leaf_hashes: Vec<String> = fixtures
        .next_roots
        .iter()
        .map(|nr| mmr_leaf_hash(nr).unwrap())
        .collect();
    let peaks = build_peaks(&leaf_hashes).unwrap();
    let root = bag_peaks(&peaks).unwrap();

    // Expected from the size=17 fixture entry.
    let expected_root = &fixtures
        .incremental_roots
        .iter()
        .find(|r| r.size == 17)
        .expect("no size=17 entry in fixtures")
        .root;

    assert_eq!(
        &root, expected_root,
        "17-receipt root mismatch: Rust={root}, Python={expected_root}"
    );
}

/// Verify inclusion proofs are valid for the 17-receipt MMR.
#[test]
fn inclusion_proofs_valid_for_17_receipts() {
    let fixtures = load_fixtures();
    let next_roots = &fixtures.next_roots;

    let info = mmr_root_from_next_roots(next_roots).unwrap();

    // Test proofs at various indices: first, middle, last, powers of two.
    for idx in [0, 1, 2, 4, 7, 8, 15, 16] {
        let proof = build_inclusion_proof(next_roots, idx).unwrap();
        assert_eq!(proof.root, info.root, "Proof root mismatch at idx={idx}");
        assert!(
            verify_inclusion_proof(&proof),
            "Inclusion proof verification failed at idx={idx}"
        );
    }
}
