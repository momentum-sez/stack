//! # Corridor Registry — N-Factorial Pairwise Generation
//!
//! Generates pairwise corridor definitions between all registered zones in the
//! network. For N zones, this produces exactly N*(N-1)/2 unique corridor pairs.
//!
//! ## Corridor ID Generation
//!
//! Corridor IDs are deterministic: the two zone jurisdiction IDs are sorted
//! lexicographically, joined with `--`, and prefixed with
//! `org.momentum.mez.corridor.`. This guarantees the same corridor ID regardless
//! of registration order.
//!
//! ## Corridor Type Classification
//!
//! Each corridor is automatically classified based on zone metadata:
//!
//! - **CrossBorder** — zones in different countries.
//! - **IntraFederal** — same country, different zones, neither is a free zone.
//! - **FreeZoneToHost** — one zone is a free zone and the other is its host
//!   economy (same country, non-free-zone).
//! - **FreeZoneToFreeZone** — both zones are free zones (regardless of country).
//!
//! ## Spec Reference
//!
//! Supports the corridor topology enumeration required by `spec/40-corridors.md`
//! and the bridge routing graph in [`super::bridge`].

use std::collections::BTreeMap;

use serde::{Deserialize, Serialize};

// ---------------------------------------------------------------------------
// Zone Entry
// ---------------------------------------------------------------------------

/// Minimal zone information for corridor registry enumeration.
///
/// Each zone is identified by a jurisdiction ID (e.g., `pk-sifc`, `ae-dubai-difc`)
/// and carries enough metadata to classify corridor types between any two zones.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct ZoneEntry {
    /// Unique zone identifier (e.g., "org.momentum.mez.zone.pk-sifc").
    pub zone_id: String,
    /// Jurisdiction identifier (e.g., "pk-sifc", "ae-dubai-difc").
    pub jurisdiction_id: String,
    /// ISO 3166-1 alpha-2 country code derived from the first two characters
    /// of `jurisdiction_id` (e.g., "pk", "ae", "us").
    pub country_code: String,
    /// Whether this zone is a free zone (has a parent in the jurisdiction stack).
    /// Examples: DIFC, ADGM, GIFT City.
    pub is_free_zone: bool,
    /// Profile identifier for this zone's configuration.
    pub profile_id: String,
}

// ---------------------------------------------------------------------------
// Corridor Type
// ---------------------------------------------------------------------------

/// Classification of a corridor based on the relationship between its two zones.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum CorridorType {
    /// Zones are in different countries (e.g., pk-sifc <-> ae-dubai-difc).
    CrossBorder,
    /// Same country, different zones, neither is a free zone
    /// (e.g., us-ny <-> us-ca).
    IntraFederal,
    /// One zone is a free zone and the other is its host economy in the same
    /// country (e.g., ae-dubai-difc <-> ae).
    FreeZoneToHost,
    /// Both zones are free zones, regardless of country
    /// (e.g., ae-dubai-difc <-> ae-abudhabi-adgm).
    FreeZoneToFreeZone,
}

impl std::fmt::Display for CorridorType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::CrossBorder => write!(f, "cross_border"),
            Self::IntraFederal => write!(f, "intra_federal"),
            Self::FreeZoneToHost => write!(f, "free_zone_to_host"),
            Self::FreeZoneToFreeZone => write!(f, "free_zone_to_free_zone"),
        }
    }
}

// ---------------------------------------------------------------------------
// Corridor Definition
// ---------------------------------------------------------------------------

/// A corridor definition between two zones, generated by the registry.
///
/// Contains enough metadata to bootstrap a corridor lifecycle: the two zone
/// endpoints, the corridor type, and the compliance domains that must be
/// evaluated for transactions traversing this corridor.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct CorridorDefinition {
    /// Deterministic corridor identifier.
    /// Format: `org.momentum.mez.corridor.{sorted_a}--{sorted_b}`
    pub corridor_id: String,
    /// Zone ID of the lexicographically first zone.
    pub zone_a_id: String,
    /// Jurisdiction of zone A.
    pub zone_a_jurisdiction: String,
    /// Zone ID of the lexicographically second zone.
    pub zone_b_id: String,
    /// Jurisdiction of zone B.
    pub zone_b_jurisdiction: String,
    /// Automatically classified corridor type.
    pub corridor_type: CorridorType,
    /// Compliance domains required for this corridor (derived from zone profiles).
    pub compliance_domains: Vec<String>,
    /// Timestamp when this definition was generated (RFC 3339).
    pub created_at: String,
}

// ---------------------------------------------------------------------------
// Classification
// ---------------------------------------------------------------------------

/// Classify the corridor type between two zones based on their country codes
/// and free zone status.
///
/// Rules (evaluated in order):
/// 1. Both free zones -> `FreeZoneToFreeZone`
/// 2. Different countries -> `CrossBorder`
/// 3. Same country, exactly one free zone -> `FreeZoneToHost`
/// 4. Same country, neither free zone -> `IntraFederal`
pub fn classify_corridor(a: &ZoneEntry, b: &ZoneEntry) -> CorridorType {
    // Rule 1: both free zones (regardless of country).
    if a.is_free_zone && b.is_free_zone {
        return CorridorType::FreeZoneToFreeZone;
    }

    // Rule 2: different countries.
    if a.country_code != b.country_code {
        return CorridorType::CrossBorder;
    }

    // Same country from here on.

    // Rule 3: exactly one is a free zone.
    if a.is_free_zone || b.is_free_zone {
        return CorridorType::FreeZoneToHost;
    }

    // Rule 4: same country, neither free zone.
    CorridorType::IntraFederal
}

// ---------------------------------------------------------------------------
// Corridor ID Generation
// ---------------------------------------------------------------------------

/// Generate a deterministic corridor ID from two jurisdiction IDs.
///
/// The two IDs are sorted lexicographically to ensure the same corridor ID
/// regardless of argument order. The result is prefixed with
/// `org.momentum.mez.corridor.` and the two sorted IDs are joined with `--`.
///
/// # Examples
///
/// ```
/// use mez_corridor::registry::generate_corridor_id;
///
/// let id = generate_corridor_id("pk-sifc", "ae-dubai-difc");
/// assert_eq!(id, "org.momentum.mez.corridor.ae-dubai-difc--pk-sifc");
///
/// // Order does not matter:
/// let id2 = generate_corridor_id("ae-dubai-difc", "pk-sifc");
/// assert_eq!(id, id2);
/// ```
pub fn generate_corridor_id(a: &str, b: &str) -> String {
    let (first, second) = if a <= b { (a, b) } else { (b, a) };
    format!("org.momentum.mez.corridor.{first}--{second}")
}

// ---------------------------------------------------------------------------
// Corridor Registry
// ---------------------------------------------------------------------------

/// Registry of zones that generates all pairwise corridor definitions.
///
/// For N registered zones, [`generate_corridors`](CorridorRegistry::generate_corridors)
/// produces exactly N*(N-1)/2 unique corridor definitions (the upper triangle of
/// the adjacency matrix).
///
/// ## Usage
///
/// ```
/// use mez_corridor::registry::{CorridorRegistry, ZoneEntry};
///
/// let mut registry = CorridorRegistry::new();
/// registry.register_zone(ZoneEntry {
///     zone_id: "org.momentum.mez.zone.pk-sifc".into(),
///     jurisdiction_id: "pk-sifc".into(),
///     country_code: "pk".into(),
///     is_free_zone: true,
///     profile_id: "pk-sifc-profile".into(),
/// });
/// registry.register_zone(ZoneEntry {
///     zone_id: "org.momentum.mez.zone.ae-dubai-difc".into(),
///     jurisdiction_id: "ae-dubai-difc".into(),
///     country_code: "ae".into(),
///     is_free_zone: true,
///     profile_id: "ae-difc-profile".into(),
/// });
///
/// let corridors = registry.generate_corridors();
/// assert_eq!(corridors.len(), 1);
/// ```
#[derive(Debug, Clone, Default)]
pub struct CorridorRegistry {
    /// Registered zones, keyed by jurisdiction_id for deduplication.
    zones: BTreeMap<String, ZoneEntry>,
    /// Generated corridors (populated by `generate_corridors`).
    corridors: Vec<CorridorDefinition>,
}

impl CorridorRegistry {
    /// Create an empty corridor registry.
    pub fn new() -> Self {
        Self {
            zones: BTreeMap::new(),
            corridors: Vec::new(),
        }
    }

    /// Register a zone. If a zone with the same `jurisdiction_id` is already
    /// registered, it is replaced.
    ///
    /// Clears any previously generated corridors since the zone set has changed.
    pub fn register_zone(&mut self, entry: ZoneEntry) {
        self.zones.insert(entry.jurisdiction_id.clone(), entry);
        // Invalidate previously generated corridors.
        self.corridors.clear();
    }

    /// Generate all pairwise corridor definitions between registered zones.
    ///
    /// Produces N*(N-1)/2 corridors for N zones. Each pair appears exactly once.
    /// Corridor IDs are deterministic (lexicographic sort of jurisdiction IDs).
    /// Corridor type is automatically classified.
    ///
    /// The generated corridors are cached internally until the zone set changes
    /// (via [`register_zone`](Self::register_zone)).
    pub fn generate_corridors(&mut self) -> Vec<CorridorDefinition> {
        let zones: Vec<&ZoneEntry> = self.zones.values().collect();
        let mut corridors = Vec::with_capacity(zones.len() * zones.len().saturating_sub(1) / 2);

        let now = chrono::Utc::now().to_rfc3339();

        for i in 0..zones.len() {
            for j in (i + 1)..zones.len() {
                let a = zones[i];
                let b = zones[j];

                let corridor_id =
                    generate_corridor_id(&a.jurisdiction_id, &b.jurisdiction_id);
                let corridor_type = classify_corridor(a, b);

                // Derive compliance domains from the corridor type.
                let compliance_domains = default_compliance_domains(corridor_type);

                // Ensure zone_a is the lexicographically first jurisdiction.
                let (zone_a, zone_b) = if a.jurisdiction_id <= b.jurisdiction_id {
                    (a, b)
                } else {
                    (b, a)
                };

                corridors.push(CorridorDefinition {
                    corridor_id,
                    zone_a_id: zone_a.zone_id.clone(),
                    zone_a_jurisdiction: zone_a.jurisdiction_id.clone(),
                    zone_b_id: zone_b.zone_id.clone(),
                    zone_b_jurisdiction: zone_b.jurisdiction_id.clone(),
                    corridor_type,
                    compliance_domains,
                    created_at: now.clone(),
                });
            }
        }

        self.corridors = corridors.clone();
        corridors
    }

    /// Return the number of generated corridors.
    ///
    /// Returns 0 if `generate_corridors` has not been called or if the zone
    /// set changed since the last generation.
    pub fn corridor_count(&self) -> usize {
        self.corridors.len()
    }

    /// Return the number of registered zones.
    pub fn zone_count(&self) -> usize {
        self.zones.len()
    }

    /// Return all generated corridors involving a specific jurisdiction.
    pub fn corridors_for_zone(&self, jurisdiction_id: &str) -> Vec<&CorridorDefinition> {
        self.corridors
            .iter()
            .filter(|c| {
                c.zone_a_jurisdiction == jurisdiction_id
                    || c.zone_b_jurisdiction == jurisdiction_id
            })
            .collect()
    }

    /// Build a symmetric adjacency map: zone jurisdiction -> connected zone jurisdictions.
    ///
    /// Uses a `BTreeMap` for deterministic iteration order. Each zone lists all
    /// zones it has a corridor with.
    pub fn corridor_matrix(&self) -> BTreeMap<String, Vec<String>> {
        let mut matrix: BTreeMap<String, Vec<String>> = BTreeMap::new();

        for corridor in &self.corridors {
            matrix
                .entry(corridor.zone_a_jurisdiction.clone())
                .or_default()
                .push(corridor.zone_b_jurisdiction.clone());
            matrix
                .entry(corridor.zone_b_jurisdiction.clone())
                .or_default()
                .push(corridor.zone_a_jurisdiction.clone());
        }

        // Sort adjacency lists for deterministic output.
        for neighbors in matrix.values_mut() {
            neighbors.sort();
        }

        matrix
    }

    /// Return a reference to all registered zones.
    pub fn zones(&self) -> &BTreeMap<String, ZoneEntry> {
        &self.zones
    }

    /// Return a reference to the generated corridors.
    pub fn corridors(&self) -> &[CorridorDefinition] {
        &self.corridors
    }
}

// ---------------------------------------------------------------------------
// Default compliance domains
// ---------------------------------------------------------------------------

/// Return default compliance domains for a corridor type.
///
/// Cross-border corridors require the most domains (AML, sanctions, FX, customs).
/// Intra-federal corridors require fewer. Free zone corridors have their own
/// regulatory requirements.
fn default_compliance_domains(corridor_type: CorridorType) -> Vec<String> {
    match corridor_type {
        CorridorType::CrossBorder => vec![
            "AML_CFT".to_string(),
            "SANCTIONS".to_string(),
            "FX_CONTROL".to_string(),
            "CUSTOMS".to_string(),
            "TAX_WITHHOLDING".to_string(),
            "DATA_PRIVACY".to_string(),
        ],
        CorridorType::IntraFederal => vec![
            "AML_CFT".to_string(),
            "TAX_WITHHOLDING".to_string(),
            "DATA_PRIVACY".to_string(),
        ],
        CorridorType::FreeZoneToHost => vec![
            "AML_CFT".to_string(),
            "SANCTIONS".to_string(),
            "FX_CONTROL".to_string(),
            "TAX_WITHHOLDING".to_string(),
            "LICENSING".to_string(),
        ],
        CorridorType::FreeZoneToFreeZone => vec![
            "AML_CFT".to_string(),
            "SANCTIONS".to_string(),
            "FX_CONTROL".to_string(),
            "LICENSING".to_string(),
            "DATA_PRIVACY".to_string(),
        ],
    }
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;

    /// Helper to create a `ZoneEntry` with minimal boilerplate.
    fn zone(
        zone_id: &str,
        jurisdiction_id: &str,
        country_code: &str,
        is_free_zone: bool,
    ) -> ZoneEntry {
        ZoneEntry {
            zone_id: zone_id.to_string(),
            jurisdiction_id: jurisdiction_id.to_string(),
            country_code: country_code.to_string(),
            is_free_zone,
            profile_id: format!("{jurisdiction_id}-profile"),
        }
    }

    // -- Combinatorial count tests --

    #[test]
    fn empty_registry_produces_no_corridors() {
        let mut registry = CorridorRegistry::new();
        let corridors = registry.generate_corridors();
        assert!(corridors.is_empty());
        assert_eq!(registry.corridor_count(), 0);
    }

    #[test]
    fn single_zone_produces_no_corridors() {
        let mut registry = CorridorRegistry::new();
        registry.register_zone(zone(
            "org.momentum.mez.zone.pk-sifc",
            "pk-sifc",
            "pk",
            true,
        ));
        let corridors = registry.generate_corridors();
        assert!(corridors.is_empty());
        assert_eq!(registry.corridor_count(), 0);
    }

    #[test]
    fn two_zones_produce_one_corridor() {
        let mut registry = CorridorRegistry::new();
        registry.register_zone(zone(
            "org.momentum.mez.zone.pk-sifc",
            "pk-sifc",
            "pk",
            true,
        ));
        registry.register_zone(zone(
            "org.momentum.mez.zone.ae-dubai-difc",
            "ae-dubai-difc",
            "ae",
            true,
        ));
        let corridors = registry.generate_corridors();
        assert_eq!(corridors.len(), 1);
        assert_eq!(registry.corridor_count(), 1);
    }

    #[test]
    fn three_zones_produce_three_corridors() {
        let mut registry = CorridorRegistry::new();
        registry.register_zone(zone("z-pk", "pk-sifc", "pk", true));
        registry.register_zone(zone("z-ae", "ae-dubai-difc", "ae", true));
        registry.register_zone(zone("z-gb", "gb-london", "gb", false));
        let corridors = registry.generate_corridors();
        assert_eq!(corridors.len(), 3); // 3*(3-1)/2 = 3
    }

    #[test]
    fn n_zones_produce_n_choose_2_corridors() {
        let mut registry = CorridorRegistry::new();
        let zone_defs = [
            ("z-pk", "pk-sifc", "pk", true),
            ("z-ae", "ae-dubai-difc", "ae", true),
            ("z-gb", "gb-london", "gb", false),
            ("z-us-ny", "us-ny", "us", false),
            ("z-us-ca", "us-ca", "us", false),
            ("z-sg", "sg-central", "sg", false),
        ];
        for (zid, jid, cc, fz) in &zone_defs {
            registry.register_zone(zone(zid, jid, cc, *fz));
        }
        let corridors = registry.generate_corridors();
        let n = zone_defs.len();
        assert_eq!(corridors.len(), n * (n - 1) / 2); // 6*5/2 = 15
    }

    // -- Determinism tests --

    #[test]
    fn corridor_ids_deterministic_regardless_of_registration_order() {
        // Register in order A, B.
        let mut reg1 = CorridorRegistry::new();
        reg1.register_zone(zone("z-ae", "ae-dubai-difc", "ae", true));
        reg1.register_zone(zone("z-pk", "pk-sifc", "pk", true));
        let corridors1 = reg1.generate_corridors();

        // Register in order B, A.
        let mut reg2 = CorridorRegistry::new();
        reg2.register_zone(zone("z-pk", "pk-sifc", "pk", true));
        reg2.register_zone(zone("z-ae", "ae-dubai-difc", "ae", true));
        let corridors2 = reg2.generate_corridors();

        assert_eq!(corridors1.len(), 1);
        assert_eq!(corridors2.len(), 1);
        assert_eq!(corridors1[0].corridor_id, corridors2[0].corridor_id);
        assert_eq!(
            corridors1[0].corridor_id,
            "org.momentum.mez.corridor.ae-dubai-difc--pk-sifc"
        );
    }

    #[test]
    fn generate_corridor_id_is_symmetric() {
        let id_ab = generate_corridor_id("pk-sifc", "ae-dubai-difc");
        let id_ba = generate_corridor_id("ae-dubai-difc", "pk-sifc");
        assert_eq!(id_ab, id_ba);
    }

    // -- Classification tests --

    #[test]
    fn classify_cross_border() {
        let pk = zone("z-pk", "pk-sifc", "pk", false);
        let ae = zone("z-ae", "ae-mainland", "ae", false);
        assert_eq!(classify_corridor(&pk, &ae), CorridorType::CrossBorder);
    }

    #[test]
    fn classify_intra_federal() {
        let ny = zone("z-us-ny", "us-ny", "us", false);
        let ca = zone("z-us-ca", "us-ca", "us", false);
        assert_eq!(classify_corridor(&ny, &ca), CorridorType::IntraFederal);
    }

    #[test]
    fn classify_free_zone_to_host() {
        let difc = zone("z-ae-difc", "ae-dubai-difc", "ae", true);
        let ae_main = zone("z-ae", "ae", "ae", false);
        assert_eq!(
            classify_corridor(&difc, &ae_main),
            CorridorType::FreeZoneToHost
        );
        // Symmetric.
        assert_eq!(
            classify_corridor(&ae_main, &difc),
            CorridorType::FreeZoneToHost
        );
    }

    #[test]
    fn classify_free_zone_to_free_zone_same_country() {
        let difc = zone("z-ae-difc", "ae-dubai-difc", "ae", true);
        let adgm = zone("z-ae-adgm", "ae-abudhabi-adgm", "ae", true);
        assert_eq!(
            classify_corridor(&difc, &adgm),
            CorridorType::FreeZoneToFreeZone
        );
    }

    #[test]
    fn classify_free_zone_to_free_zone_different_country() {
        let difc = zone("z-ae-difc", "ae-dubai-difc", "ae", true);
        let pk_sifc = zone("z-pk-sifc", "pk-sifc", "pk", true);
        // Both free zones -> FreeZoneToFreeZone takes priority over CrossBorder.
        assert_eq!(
            classify_corridor(&difc, &pk_sifc),
            CorridorType::FreeZoneToFreeZone
        );
    }

    // -- Query tests --

    #[test]
    fn corridors_for_zone_returns_correct_subset() {
        let mut registry = CorridorRegistry::new();
        registry.register_zone(zone("z-pk", "pk-sifc", "pk", true));
        registry.register_zone(zone("z-ae", "ae-dubai-difc", "ae", true));
        registry.register_zone(zone("z-gb", "gb-london", "gb", false));
        registry.register_zone(zone("z-us", "us-ny", "us", false));
        registry.generate_corridors();

        let pk_corridors = registry.corridors_for_zone("pk-sifc");
        // pk-sifc should appear in 3 corridors (paired with ae, gb, us).
        assert_eq!(pk_corridors.len(), 3);
        for c in &pk_corridors {
            assert!(
                c.zone_a_jurisdiction == "pk-sifc" || c.zone_b_jurisdiction == "pk-sifc"
            );
        }

        // Non-existent zone returns empty.
        let none = registry.corridors_for_zone("xx-nowhere");
        assert!(none.is_empty());
    }

    #[test]
    fn corridor_matrix_is_symmetric() {
        let mut registry = CorridorRegistry::new();
        registry.register_zone(zone("z-pk", "pk-sifc", "pk", true));
        registry.register_zone(zone("z-ae", "ae-dubai-difc", "ae", true));
        registry.register_zone(zone("z-gb", "gb-london", "gb", false));
        registry.generate_corridors();

        let matrix = registry.corridor_matrix();

        // For every entry (a -> [..., b, ...]), b -> [..., a, ...] must hold.
        for (zone_a, neighbors) in &matrix {
            for zone_b in neighbors {
                let b_neighbors = matrix.get(zone_b).expect("symmetric key must exist");
                assert!(
                    b_neighbors.contains(zone_a),
                    "{zone_b} should list {zone_a} as neighbor"
                );
            }
        }

        // Each zone should have exactly 2 neighbors (3 zones total).
        for neighbors in matrix.values() {
            assert_eq!(neighbors.len(), 2);
        }
    }

    // -- Serialization tests --

    #[test]
    fn corridor_definition_serialization_roundtrip() {
        let mut registry = CorridorRegistry::new();
        registry.register_zone(zone("z-pk", "pk-sifc", "pk", true));
        registry.register_zone(zone("z-ae", "ae-dubai-difc", "ae", true));
        let corridors = registry.generate_corridors();

        let json = serde_json::to_string(&corridors[0]).unwrap();
        let de: CorridorDefinition = serde_json::from_str(&json).unwrap();

        assert_eq!(de.corridor_id, corridors[0].corridor_id);
        assert_eq!(de.corridor_type, corridors[0].corridor_type);
        assert_eq!(de.zone_a_jurisdiction, corridors[0].zone_a_jurisdiction);
        assert_eq!(de.zone_b_jurisdiction, corridors[0].zone_b_jurisdiction);
        assert_eq!(de.compliance_domains, corridors[0].compliance_domains);
    }

    #[test]
    fn zone_entry_serialization_roundtrip() {
        let entry = zone("z-pk", "pk-sifc", "pk", true);
        let json = serde_json::to_string(&entry).unwrap();
        let de: ZoneEntry = serde_json::from_str(&json).unwrap();
        assert_eq!(de, entry);
    }

    #[test]
    fn corridor_type_serialization() {
        let ct = CorridorType::FreeZoneToFreeZone;
        let json = serde_json::to_string(&ct).unwrap();
        assert_eq!(json, "\"free_zone_to_free_zone\"");

        let de: CorridorType = serde_json::from_str(&json).unwrap();
        assert_eq!(de, ct);
    }

    // -- Edge cases --

    #[test]
    fn duplicate_zone_registration_replaces_and_clears_corridors() {
        let mut registry = CorridorRegistry::new();
        registry.register_zone(zone("z-pk", "pk-sifc", "pk", true));
        registry.register_zone(zone("z-ae", "ae-dubai-difc", "ae", true));
        registry.generate_corridors();
        assert_eq!(registry.corridor_count(), 1);

        // Re-register pk-sifc with different profile.
        registry.register_zone(ZoneEntry {
            zone_id: "z-pk-updated".to_string(),
            jurisdiction_id: "pk-sifc".to_string(),
            country_code: "pk".to_string(),
            is_free_zone: false,
            profile_id: "updated-profile".to_string(),
        });

        // Corridors should be cleared.
        assert_eq!(registry.corridor_count(), 0);

        // Regenerate.
        let corridors = registry.generate_corridors();
        assert_eq!(corridors.len(), 1);
        // Type should now be CrossBorder (pk non-free, ae free -> one free zone
        // but different countries -> CrossBorder since different country_code).
        assert_eq!(corridors[0].corridor_type, CorridorType::CrossBorder);
    }

    #[test]
    fn corridor_type_display() {
        assert_eq!(CorridorType::CrossBorder.to_string(), "cross_border");
        assert_eq!(CorridorType::IntraFederal.to_string(), "intra_federal");
        assert_eq!(
            CorridorType::FreeZoneToHost.to_string(),
            "free_zone_to_host"
        );
        assert_eq!(
            CorridorType::FreeZoneToFreeZone.to_string(),
            "free_zone_to_free_zone"
        );
    }

    #[test]
    fn compliance_domains_vary_by_type() {
        let cross = default_compliance_domains(CorridorType::CrossBorder);
        let intra = default_compliance_domains(CorridorType::IntraFederal);
        let fz_host = default_compliance_domains(CorridorType::FreeZoneToHost);
        let fz_fz = default_compliance_domains(CorridorType::FreeZoneToFreeZone);

        // Cross-border should have the most domains.
        assert!(cross.len() >= intra.len());
        // All should contain AML_CFT.
        assert!(cross.contains(&"AML_CFT".to_string()));
        assert!(intra.contains(&"AML_CFT".to_string()));
        assert!(fz_host.contains(&"AML_CFT".to_string()));
        assert!(fz_fz.contains(&"AML_CFT".to_string()));
        // Cross-border should contain CUSTOMS.
        assert!(cross.contains(&"CUSTOMS".to_string()));
        // Intra-federal should NOT contain CUSTOMS.
        assert!(!intra.contains(&"CUSTOMS".to_string()));
        // Free zone corridors should contain LICENSING.
        assert!(fz_host.contains(&"LICENSING".to_string()));
        assert!(fz_fz.contains(&"LICENSING".to_string()));
    }
}
