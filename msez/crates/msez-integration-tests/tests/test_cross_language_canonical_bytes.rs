//! # Cross-Language Canonical Bytes Test
//!
//! Loads fixture data generated by Python `tools/lawpack.py:jcs_canonicalize()`
//! and verifies that Rust `CanonicalBytes::new()` + `sha256_digest()` produce
//! identical results.
//!
//! ## Fixture Source
//!
//! `tests/fixtures/canonical_bytes.json` — generated by running:
//! ```text
//! python3 -c "
//! from tools.lawpack import jcs_canonicalize
//! import json, hashlib
//! ...
//! "
//! ```
//!
//! ## Known Divergence: RFC 3339 Timestamp Strings
//!
//! Python `jcs_canonicalize` passes RFC 3339 timestamp strings through unchanged
//! (it only normalizes Python `datetime` objects). Rust `CanonicalBytes::new()`
//! normalizes all RFC 3339 strings to UTC with `Z` suffix, truncated to seconds.
//!
//! Test cases with `has_rfc3339_string: true` are tested separately to document
//! this intentional behavioral difference. For data that does not contain RFC 3339
//! strings, the implementations produce byte-identical output.

use msez_core::{sha256_digest, CanonicalBytes};
use serde::Deserialize;
use serde_json::Value;

/// Path to the fixture file, relative to the workspace root.
const FIXTURE_PATH: &str = "tests/fixtures/canonical_bytes.json";

#[derive(Debug, Deserialize)]
struct FixtureFile {
    test_cases: Vec<TestCase>,
}

#[derive(Debug, Deserialize)]
struct TestCase {
    name: String,
    input: Value,
    has_rfc3339_string: bool,
    canonical_utf8: String,
    sha256_digest: String,
    #[serde(default)]
    rust_canonical_utf8: Option<String>,
}

fn load_fixtures() -> FixtureFile {
    // Navigate from the crate directory to the repo root.
    let manifest_dir = std::path::Path::new(env!("CARGO_MANIFEST_DIR"));
    let repo_root = manifest_dir
        .parent()
        .expect("crates/ dir")
        .parent()
        .expect("msez/ dir")
        .parent()
        .expect("repo root");
    let fixture_path = repo_root.join(FIXTURE_PATH);
    let content = std::fs::read_to_string(&fixture_path).unwrap_or_else(|e| {
        panic!(
            "Failed to read fixture file at {}: {e}",
            fixture_path.display()
        )
    });
    serde_json::from_str(&content).expect("Failed to parse fixture JSON")
}

/// Test that Rust `CanonicalBytes::new()` produces identical canonical bytes
/// and SHA-256 digests as Python `jcs_canonicalize()` for all non-datetime
/// test cases.
#[test]
fn canonical_bytes_match_python_fixtures() {
    let fixtures = load_fixtures();
    let mut tested = 0;

    for tc in &fixtures.test_cases {
        if tc.has_rfc3339_string {
            continue; // Tested separately below.
        }

        let canonical = CanonicalBytes::new(&tc.input).unwrap_or_else(|e| {
            panic!("CanonicalBytes::new() failed for case '{}': {e}", tc.name)
        });

        // Verify canonical UTF-8 matches Python output.
        let rust_utf8 = std::str::from_utf8(canonical.as_bytes()).unwrap_or_else(|e| {
            panic!(
                "Canonical bytes are not valid UTF-8 for case '{}': {e}",
                tc.name
            )
        });
        assert_eq!(
            rust_utf8, tc.canonical_utf8,
            "Canonical UTF-8 mismatch for case '{}':\n  Rust:   {rust_utf8}\n  Python: {}",
            tc.name, tc.canonical_utf8
        );

        // Verify canonical hex matches Python output.
        let rust_hex: String = canonical
            .as_bytes()
            .iter()
            .map(|b| format!("{b:02x}"))
            .collect();
        let python_hex: String = tc
            .canonical_utf8
            .as_bytes()
            .iter()
            .map(|b| format!("{b:02x}"))
            .collect();
        assert_eq!(
            rust_hex, python_hex,
            "Canonical hex mismatch for case '{}'",
            tc.name
        );

        // Verify SHA-256 digest matches Python output.
        let digest = sha256_digest(&canonical);
        assert_eq!(
            digest.to_hex(),
            tc.sha256_digest,
            "SHA-256 digest mismatch for case '{}':\n  Rust:   {}\n  Python: {}",
            tc.name,
            digest.to_hex(),
            tc.sha256_digest
        );

        tested += 1;
    }

    // Ensure we actually tested a meaningful number of cases.
    assert!(
        tested >= 12,
        "Expected at least 12 non-datetime test cases, got {tested}"
    );
}

/// Test that RFC 3339 timestamp strings are handled with the documented
/// divergence: Rust normalizes them to UTC+Z, Python passes them through.
#[test]
fn canonical_bytes_timestamp_divergence_documented() {
    let fixtures = load_fixtures();

    for tc in &fixtures.test_cases {
        if !tc.has_rfc3339_string {
            continue;
        }

        let canonical = CanonicalBytes::new(&tc.input).unwrap_or_else(|e| {
            panic!("CanonicalBytes::new() failed for case '{}': {e}", tc.name)
        });

        let rust_utf8 = std::str::from_utf8(canonical.as_bytes()).unwrap();

        // Rust normalizes RFC 3339 strings — verify it does NOT match
        // the Python output (which passes the string through as-is).
        assert_ne!(
            rust_utf8, tc.canonical_utf8,
            "Case '{}': Expected Rust to normalize RFC 3339 string differently from Python.\n  \
             Rust:   {rust_utf8}\n  Python: {}",
            tc.name, tc.canonical_utf8
        );

        // If the fixture provides the expected Rust canonical form, verify it.
        if let Some(expected_rust) = &tc.rust_canonical_utf8 {
            assert_eq!(
                rust_utf8, expected_rust,
                "Case '{}': Rust canonical does not match expected Rust form.\n  \
                 Got:      {rust_utf8}\n  Expected: {expected_rust}",
                tc.name
            );
        }

        // Verify the digest is valid (64 hex chars) even though it differs
        // from the Python digest.
        let digest = sha256_digest(&canonical);
        assert_eq!(digest.to_hex().len(), 64);
        assert_ne!(
            digest.to_hex(),
            tc.sha256_digest,
            "Case '{}': Digest unexpectedly matches Python — \
             the normalization difference should produce a different digest",
            tc.name
        );
    }
}

/// Verify that each test case produces deterministic output — running
/// canonicalization twice yields identical bytes.
#[test]
fn canonical_bytes_deterministic_across_fixtures() {
    let fixtures = load_fixtures();

    for tc in &fixtures.test_cases {
        let c1 = CanonicalBytes::new(&tc.input).unwrap();
        let c2 = CanonicalBytes::new(&tc.input).unwrap();
        assert_eq!(
            c1.as_bytes(),
            c2.as_bytes(),
            "Non-deterministic canonicalization for case '{}'",
            tc.name
        );
    }
}

/// Verify idempotency: canonicalizing the canonical output produces
/// identical bytes.
#[test]
fn canonical_bytes_idempotent_across_fixtures() {
    let fixtures = load_fixtures();

    for tc in &fixtures.test_cases {
        let first = CanonicalBytes::new(&tc.input).unwrap();
        let reparsed: Value = serde_json::from_slice(first.as_bytes()).unwrap();
        let second = CanonicalBytes::new(&reparsed).unwrap();
        assert_eq!(
            first.as_bytes(),
            second.as_bytes(),
            "Non-idempotent canonicalization for case '{}'",
            tc.name
        );
    }
}

/// Verify that different inputs from the fixtures produce different digests.
#[test]
fn canonical_bytes_distinct_inputs_distinct_digests() {
    let fixtures = load_fixtures();
    let mut digests = std::collections::HashSet::new();

    for tc in &fixtures.test_cases {
        let canonical = CanonicalBytes::new(&tc.input).unwrap();
        let digest = sha256_digest(&canonical);
        let hex = digest.to_hex();
        assert!(
            digests.insert(hex.clone()),
            "Duplicate digest found for case '{}': {hex}",
            tc.name
        );
    }
}
