//! # Deploy Generate CLI â€” N-Zone Docker Compose Generator
//!
//! Provides the `mez deploy generate` subcommand for generating Docker Compose
//! files for arbitrary N-zone deployments with full corridor mesh.
//!
//! ## Usage
//!
//! ```bash
//! # Generate a 5-zone deployment:
//! mez deploy generate --zones pk-sifc,ae-abudhabi-adgm,sg,hk,ky \
//!     --output deploy/docker/docker-compose.generated.yaml
//!
//! # Generate with synthetic zones:
//! mez deploy generate --zones pk-sifc,ae-abudhabi-adgm,synth-atlantic-fintech \
//!     --output deploy/docker/docker-compose.generated.yaml
//! ```

use std::path::Path;

use anyhow::{Context, Result, bail};
use clap::{Args, Subcommand};

/// Deploy subcommand arguments.
#[derive(Args, Debug)]
pub struct DeployArgs {
    #[command(subcommand)]
    pub command: DeployCommand,
}

/// Available deploy subcommands.
#[derive(Subcommand, Debug)]
pub enum DeployCommand {
    /// Generate a Docker Compose file for N-zone deployment.
    Generate {
        /// Comma-separated list of jurisdiction IDs to deploy.
        #[arg(long, value_delimiter = ',')]
        zones: Vec<String>,

        /// Output path for the generated docker-compose.yaml.
        #[arg(long)]
        output: std::path::PathBuf,
    },
}

/// Execute the deploy subcommand.
pub fn run_deploy(args: &DeployArgs, repo_root: &Path) -> Result<u8> {
    match &args.command {
        DeployCommand::Generate { zones, output } => {
            run_generate(zones, output, repo_root)
        }
    }
}

fn run_generate(
    zones: &[String],
    output: &Path,
    repo_root: &Path,
) -> Result<u8> {
    if zones.is_empty() {
        bail!("at least one zone must be specified with --zones");
    }

    // Validate all zone.yaml files exist.
    let mut zone_configs: Vec<ZoneConfig> = Vec::new();
    for (idx, jid) in zones.iter().enumerate() {
        let zone_path = repo_root.join("jurisdictions").join(jid).join("zone.yaml");
        if !zone_path.exists() {
            bail!(
                "zone '{}' not found at {}",
                jid,
                zone_path.display()
            );
        }

        let content = std::fs::read_to_string(&zone_path)
            .with_context(|| format!("reading zone.yaml for {jid}"))?;
        let yaml: serde_yaml::Value = serde_yaml::from_str(&content)?;

        let zone_id = yaml
            .get("zone_id")
            .and_then(|v| v.as_str())
            .unwrap_or(jid)
            .to_string();

        let zone_type = yaml
            .get("zone_type")
            .and_then(|v| v.as_str())
            .unwrap_or("natural")
            .to_string();

        zone_configs.push(ZoneConfig {
            jurisdiction_id: jid.clone(),
            zone_id,
            zone_type,
            api_port: 8080 + idx as u16,
            pg_port: 5432 + idx as u16,
        });
    }

    // Generate corridor definitions.
    let n = zone_configs.len();
    let mut corridor_defs = Vec::new();
    for i in 0..n {
        for j in (i + 1)..n {
            let a = &zone_configs[i].jurisdiction_id;
            let b = &zone_configs[j].jurisdiction_id;
            let (first, second) = if a <= b { (a, b) } else { (b, a) };
            let corridor_id = format!("org.momentum.mez.corridor.{first}--{second}");
            corridor_defs.push(serde_json::json!({
                "corridor_id": corridor_id,
                "zone_a": first,
                "zone_b": second,
                "corridor_type": "cross_border",
            }));
        }
    }

    let corridors_json = serde_json::to_string(&corridor_defs)?;

    // Generate compose YAML.
    let mut compose = String::new();
    compose.push_str(&format!(
        "# Auto-generated Docker Compose for {n}-zone MEZ deployment\n"
    ));
    compose.push_str(&format!("# Zones: {}\n", zones.join(", ")));
    compose.push_str(&format!(
        "# Corridors: {} (N*(N-1)/2 = {})\n",
        corridor_defs.len(),
        n * (n.saturating_sub(1)) / 2
    ));
    compose.push_str("#\n");
    compose.push_str("# Generated by: mez deploy generate\n\n");
    compose.push_str("services:\n");

    for zc in &zone_configs {
        let service_name = format!(
            "mez-zone-{}",
            zc.jurisdiction_id.replace('.', "-")
        );

        // Peer list: all other zones.
        let peers: Vec<String> = zone_configs
            .iter()
            .filter(|z| z.jurisdiction_id != zc.jurisdiction_id)
            .map(|z| {
                format!(
                    "http://mez-zone-{}:8080",
                    z.jurisdiction_id.replace('.', "-")
                )
            })
            .collect();

        compose.push_str(&format!("  {service_name}:\n"));
        compose.push_str("    build:\n");
        compose.push_str("      context: ../..\n");
        compose.push_str("      dockerfile: deploy/docker/Dockerfile\n");
        compose.push_str(&format!(
            "    container_name: {service_name}\n"
        ));
        compose.push_str("    environment:\n");
        compose.push_str(&format!(
            "      ZONE_ID: \"{}\"\n",
            zc.zone_id
        ));
        compose.push_str(&format!(
            "      JURISDICTION_ID: \"{}\"\n",
            zc.jurisdiction_id
        ));
        compose.push_str(&format!(
            "      ZONE_TYPE: \"{}\"\n",
            zc.zone_type
        ));
        compose.push_str(&format!(
            "      AUTH_TOKEN: \"${{ZONE_{}_AUTH_TOKEN:?must be set}}\"\n",
            zc.jurisdiction_id
                .to_uppercase()
                .replace('-', "_")
        ));
        compose.push_str(&format!(
            "      POSTGRES_PASSWORD: \"${{POSTGRES_PASSWORD:?must be set}}\"\n"
        ));
        compose.push_str(&format!(
            "      POSTGRES_HOST: \"pg-{}\"\n",
            zc.jurisdiction_id.replace('.', "-")
        ));
        compose.push_str(&format!(
            "      CORRIDOR_PEERS: \"{}\"\n",
            peers.join(",")
        ));
        compose.push_str(&format!(
            "      CORRIDOR_DEFINITIONS: '{}'\n",
            corridors_json.replace('\'', "''")
        ));
        compose.push_str("    ports:\n");
        compose.push_str(&format!(
            "      - \"{}:8080\"\n",
            zc.api_port
        ));
        compose.push_str("    networks:\n");
        compose.push_str("      - mez-corridor-net\n");
        compose.push_str("    depends_on:\n");
        compose.push_str(&format!(
            "      pg-{}:\n",
            zc.jurisdiction_id.replace('.', "-")
        ));
        compose.push_str("        condition: service_healthy\n");
        compose.push_str("    healthcheck:\n");
        compose.push_str("      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:8080/health/liveness\"]\n");
        compose.push_str("      interval: 10s\n");
        compose.push_str("      timeout: 5s\n");
        compose.push_str("      retries: 5\n\n");
    }

    // PostgreSQL services.
    for zc in &zone_configs {
        let pg_name = format!(
            "pg-{}",
            zc.jurisdiction_id.replace('.', "-")
        );
        compose.push_str(&format!("  {pg_name}:\n"));
        compose.push_str("    image: postgres:16-alpine\n");
        compose.push_str(&format!("    container_name: {pg_name}\n"));
        compose.push_str("    environment:\n");
        compose.push_str("      POSTGRES_PASSWORD: \"${POSTGRES_PASSWORD:?must be set}\"\n");
        compose.push_str(&format!(
            "      POSTGRES_DB: \"mez_{}\"\n",
            zc.jurisdiction_id.replace('-', "_")
        ));
        compose.push_str("    ports:\n");
        compose.push_str(&format!(
            "      - \"{}:5432\"\n",
            zc.pg_port
        ));
        compose.push_str("    networks:\n");
        compose.push_str("      - mez-corridor-net\n");
        compose.push_str("    healthcheck:\n");
        compose.push_str("      test: [\"CMD-SHELL\", \"pg_isready -U postgres\"]\n");
        compose.push_str("      interval: 5s\n");
        compose.push_str("      timeout: 5s\n");
        compose.push_str("      retries: 5\n");
        compose.push_str("    volumes:\n");
        compose.push_str(&format!(
            "      - {pg_name}-data:/var/lib/postgresql/data\n\n"
        ));
    }

    // Networks.
    compose.push_str("networks:\n");
    compose.push_str("  mez-corridor-net:\n");
    compose.push_str("    driver: bridge\n\n");

    // Volumes.
    compose.push_str("volumes:\n");
    for zc in &zone_configs {
        let pg_name = format!(
            "pg-{}",
            zc.jurisdiction_id.replace('.', "-")
        );
        compose.push_str(&format!("  {pg_name}-data:\n"));
    }

    // Write output.
    let output_resolved = if output.is_absolute() {
        output.to_path_buf()
    } else {
        repo_root.join(output)
    };

    if let Some(parent) = output_resolved.parent() {
        std::fs::create_dir_all(parent)
            .with_context(|| format!("creating output directory: {}", parent.display()))?;
    }

    std::fs::write(&output_resolved, &compose)
        .with_context(|| format!("writing compose file: {}", output_resolved.display()))?;

    println!("  zones:     {n}");
    println!("  corridors: {}", corridor_defs.len());
    println!("  wrote:     {}", output_resolved.display());

    for zc in &zone_configs {
        println!(
            "    {} (API :{}, PG :{}) [{}]",
            zc.jurisdiction_id, zc.api_port, zc.pg_port, zc.zone_type
        );
    }

    Ok(0)
}

struct ZoneConfig {
    jurisdiction_id: String,
    zone_id: String,
    zone_type: String,
    api_port: u16,
    pg_port: u16,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn deploy_args_parse() {
        // Just verify types compile and Debug works.
        let _ = std::any::type_name::<DeployArgs>();
        let _ = std::any::type_name::<DeployCommand>();
    }
}
