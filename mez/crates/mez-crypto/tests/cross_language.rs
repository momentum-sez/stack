//! # Cross-Language Compatibility Tests
//!
//! Validates that the Rust `mez-crypto` implementation produces identical
//! results to the Python `tools/` implementations for:
//!
//! - **Canonical bytes** — `CanonicalBytes::new()` matches `jcs_canonicalize()`.
//! - **SHA-256 digests** — `sha256_digest()` matches `hashlib.sha256()`.
//! - **MMR roots** — `mmr_root_from_next_roots()` matches `tools/mmr.py`.
//! - **MMR inclusion proofs** — proofs generated by Rust verify against Python fixtures.
//! - **CAS digests** — `ContentAddressedStore::store()` produces digests matching Python.
//! - **Ed25519 signing** — signatures over `CanonicalBytes` are deterministic and
//!   use the same canonicalization path as `tools/vc.py`.
//!
//! ## Fixture Generation
//!
//! All expected values in this file were generated by running the corresponding
//! Python functions and recording their output. The Python commands used:
//!
//! ```python
//! from tools.lawpack import jcs_canonicalize
//! from tools.mmr import mmr_root_from_next_roots, build_inclusion_proof
//! import hashlib
//! ```
//!
//! If these tests fail, it indicates a canonicalization or algorithm divergence
//! between the Rust and Python implementations — a production-blocking defect.

use mez_core::{sha256_digest, CanonicalBytes};
use mez_crypto::mmr::{
    bag_peaks, build_inclusion_proof, build_peaks, mmr_leaf_hash, mmr_node_hash,
    mmr_root_from_next_roots, verify_inclusion_proof, MerkleMountainRange,
};
use serde_json::json;

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

/// Matches Python's `hashlib.sha256(f"receipt-{i}".encode("utf-8")).hexdigest()`.
fn receipt_hash(i: usize) -> String {
    let data = format!("receipt-{i}");
    mez_core::sha256_raw(data.as_bytes())
}

// ===========================================================================
// SECTION 1: Canonical Bytes — CanonicalBytes::new() matches jcs_canonicalize()
// ===========================================================================

/// Test vectors generated by Python `jcs_canonicalize()`.
///
/// Each test case verifies that `CanonicalBytes::new()` produces the same
/// byte sequence as Python's `jcs_canonicalize()`, and that the SHA-256
/// digest of those bytes matches.
#[test]
fn canonical_bytes_match_python_case_0() {
    // Python: jcs_canonicalize({"name": "test", "value": 42})
    let value = json!({"name": "test", "value": 42});
    let cb = CanonicalBytes::new(&value).unwrap();
    let canonical_str = std::str::from_utf8(cb.as_bytes()).unwrap();
    assert_eq!(canonical_str, r#"{"name":"test","value":42}"#);
    let digest = sha256_digest(&cb);
    assert_eq!(
        digest.to_hex(),
        "9a304be829134dbe6b6ccc54e7e78e6e0b477c48a75b8e3042389dbd61617569"
    );
}

#[test]
fn canonical_bytes_match_python_case_1() {
    // Python: jcs_canonicalize({"nested": {"key": "value"}, "array": [1, 2, 3]})
    let value = json!({"nested": {"key": "value"}, "array": [1, 2, 3]});
    let cb = CanonicalBytes::new(&value).unwrap();
    let canonical_str = std::str::from_utf8(cb.as_bytes()).unwrap();
    assert_eq!(
        canonical_str,
        r#"{"array":[1,2,3],"nested":{"key":"value"}}"#
    );
    let digest = sha256_digest(&cb);
    assert_eq!(
        digest.to_hex(),
        "dbb871dfbdafb17761dc55b98f9ff3f96596222000c5cb7ce0ab891213142229"
    );
}

#[test]
fn canonical_bytes_match_python_case_2() {
    // Python: jcs_canonicalize({"amount": 1000, "currency": "PKR"})
    let value = json!({"amount": 1000, "currency": "PKR"});
    let cb = CanonicalBytes::new(&value).unwrap();
    let canonical_str = std::str::from_utf8(cb.as_bytes()).unwrap();
    assert_eq!(canonical_str, r#"{"amount":1000,"currency":"PKR"}"#);
    let digest = sha256_digest(&cb);
    assert_eq!(
        digest.to_hex(),
        "9b1be233625c8651ac5b8e7735aa2b081ea88250cf2db4dd0f22325ad586fa60"
    );
}

#[test]
fn canonical_bytes_match_python_case_3_key_sorting() {
    // Python: jcs_canonicalize({"b": 2, "a": 1}) → {"a":1,"b":2}
    let value = json!({"b": 2, "a": 1});
    let cb = CanonicalBytes::new(&value).unwrap();
    let canonical_str = std::str::from_utf8(cb.as_bytes()).unwrap();
    assert_eq!(canonical_str, r#"{"a":1,"b":2}"#);
    let digest = sha256_digest(&cb);
    assert_eq!(
        digest.to_hex(),
        "43258cff783fe7036d8a43033f830adfc60ec037382473548ac742b888292777"
    );
}

#[test]
fn canonical_bytes_match_python_case_4_empty_structures() {
    // Python: jcs_canonicalize({"empty_arr": [], "empty_obj": {}})
    let value = json!({"empty_arr": [], "empty_obj": {}});
    let cb = CanonicalBytes::new(&value).unwrap();
    let canonical_str = std::str::from_utf8(cb.as_bytes()).unwrap();
    assert_eq!(canonical_str, r#"{"empty_arr":[],"empty_obj":{}}"#);
    let digest = sha256_digest(&cb);
    assert_eq!(
        digest.to_hex(),
        "f41079191d354d8f29da00810acc909b27b42c69fe31d1a8ed5ff7b715055f08"
    );
}

#[test]
fn canonical_bytes_match_python_case_5_bool_null() {
    // Python: jcs_canonicalize({"bool_true": True, "bool_false": False, "null_val": None})
    let value = json!({"bool_true": true, "bool_false": false, "null_val": null});
    let cb = CanonicalBytes::new(&value).unwrap();
    let canonical_str = std::str::from_utf8(cb.as_bytes()).unwrap();
    assert_eq!(
        canonical_str,
        r#"{"bool_false":false,"bool_true":true,"null_val":null}"#
    );
    let digest = sha256_digest(&cb);
    assert_eq!(
        digest.to_hex(),
        "05f9d8beb89ba7e439632b4332667e95c879f48b5c5675c75a62232f04a2c931"
    );
}

#[test]
fn canonical_bytes_match_python_case_6_strings() {
    // Python: jcs_canonicalize({"unicode": "hello world", "id": "abc-123"})
    let value = json!({"unicode": "hello world", "id": "abc-123"});
    let cb = CanonicalBytes::new(&value).unwrap();
    let canonical_str = std::str::from_utf8(cb.as_bytes()).unwrap();
    assert_eq!(canonical_str, r#"{"id":"abc-123","unicode":"hello world"}"#);
    let digest = sha256_digest(&cb);
    assert_eq!(
        digest.to_hex(),
        "4586e8b896f23d72f0219430a0e2cab2dd92ec1ed2df82028e684a113d65f73b"
    );
}

#[test]
fn canonical_bytes_match_python_case_7_deep_nesting() {
    // Python: jcs_canonicalize({"deep": {"level1": {"level2": {"level3": "value"}}}})
    let value = json!({"deep": {"level1": {"level2": {"level3": "value"}}}});
    let cb = CanonicalBytes::new(&value).unwrap();
    let canonical_str = std::str::from_utf8(cb.as_bytes()).unwrap();
    assert_eq!(
        canonical_str,
        r#"{"deep":{"level1":{"level2":{"level3":"value"}}}}"#
    );
    let digest = sha256_digest(&cb);
    assert_eq!(
        digest.to_hex(),
        "d4660bc80cb35146f2ebb1e1100216f842743e7f0c8e2b026d235b4fac36c19e"
    );
}

// ===========================================================================
// SECTION 2: MMR Roots — mmr_root_from_next_roots() matches tools/mmr.py
// ===========================================================================

/// Python-generated fixtures for MMR roots at various sizes.
///
/// Generated by running `mmr_root_from_next_roots([_h(i) for i in range(1, N+1)])`
/// where `_h(i) = hashlib.sha256(f"receipt-{i}".encode()).hexdigest()`.
#[test]
fn mmr_root_1_receipt_matches_python() {
    let next_roots: Vec<String> = (1..=1).map(receipt_hash).collect();
    let info = mmr_root_from_next_roots(&next_roots).unwrap();
    assert_eq!(
        info.root,
        "29534994a3ad2af6dd418f46d4093897971cd14bea312167ad82c4b31dbbfcec"
    );
    assert_eq!(info.peaks.len(), 1);
}

#[test]
fn mmr_root_2_receipts_matches_python() {
    let next_roots: Vec<String> = (1..=2).map(receipt_hash).collect();
    let info = mmr_root_from_next_roots(&next_roots).unwrap();
    assert_eq!(
        info.root,
        "a34e6d5dac1ff07f820cc5156b41a50ce78c6a6868d81d5c5824cad0cab7250b"
    );
    assert_eq!(info.peaks.len(), 1);
}

#[test]
fn mmr_root_3_receipts_matches_python() {
    let next_roots: Vec<String> = (1..=3).map(receipt_hash).collect();
    let info = mmr_root_from_next_roots(&next_roots).unwrap();
    assert_eq!(
        info.root,
        "59140b9d370d775da9f6e8e0fb3baa63489f19f4e62d8402495b9a576ce9fa51"
    );
    assert_eq!(info.peaks.len(), 2);
}

#[test]
fn mmr_root_5_receipts_matches_python() {
    let next_roots: Vec<String> = (1..=5).map(receipt_hash).collect();
    let info = mmr_root_from_next_roots(&next_roots).unwrap();
    assert_eq!(
        info.root,
        "c05444bdd9862e94c1e9f4feefe78984eb141d7a9a8112c852011e37952e3a02"
    );
    assert_eq!(info.peaks.len(), 2);
}

#[test]
fn mmr_root_8_receipts_matches_python() {
    let next_roots: Vec<String> = (1..=8).map(receipt_hash).collect();
    let info = mmr_root_from_next_roots(&next_roots).unwrap();
    assert_eq!(
        info.root,
        "cc7b5fd2bc078fd0dc219b51d725405b4ba7cc936aeb83b4fb56d8a0ade8a9fb"
    );
    assert_eq!(info.peaks.len(), 1);
}

#[test]
fn mmr_root_9_receipts_matches_python() {
    let next_roots: Vec<String> = (1..=9).map(receipt_hash).collect();
    let info = mmr_root_from_next_roots(&next_roots).unwrap();
    assert_eq!(
        info.root,
        "2cbf59819f3070f62601d1e0c47af000896f1c7bcb3f1e421c9bcdbf6c20ef09"
    );
    assert_eq!(info.peaks.len(), 2);
}

#[test]
fn mmr_root_16_receipts_matches_python() {
    let next_roots: Vec<String> = (1..=16).map(receipt_hash).collect();
    let info = mmr_root_from_next_roots(&next_roots).unwrap();
    assert_eq!(
        info.root,
        "a4064c64f52cf7cc433bf372e64076ebd2b78a49e1e223748802831e7a7f32ad"
    );
    assert_eq!(info.peaks.len(), 1);
}

#[test]
fn mmr_root_17_receipts_matches_python() {
    let next_roots: Vec<String> = (1..=17).map(receipt_hash).collect();
    let info = mmr_root_from_next_roots(&next_roots).unwrap();
    assert_eq!(
        info.root,
        "338734a36416c5153c1a46812c5b3c2bfc3a4fa688beae56eb6ae8447143db2e"
    );
    assert_eq!(info.peaks.len(), 2);
}

// ===========================================================================
// SECTION 3: MMR Inclusion Proofs — verify against Python fixtures
// ===========================================================================

/// Verify inclusion proofs at all tested indices for 17-receipt MMR.
///
/// Python fixture: `build_inclusion_proof(next_roots_17, idx)` followed by
/// `verify_inclusion_proof(proof)` → True.
#[test]
fn mmr_inclusion_proof_idx_0_matches_python() {
    let next_roots: Vec<String> = (1..=17).map(receipt_hash).collect();
    let proof = build_inclusion_proof(&next_roots, 0).unwrap();
    assert_eq!(
        proof.leaf_hash,
        "29534994a3ad2af6dd418f46d4093897971cd14bea312167ad82c4b31dbbfcec"
    );
    assert_eq!(proof.peak_index, 0);
    assert_eq!(proof.peak_height, 4);
    assert_eq!(proof.path.len(), 4);
    assert!(verify_inclusion_proof(&proof));
}

#[test]
fn mmr_inclusion_proof_idx_1_matches_python() {
    let next_roots: Vec<String> = (1..=17).map(receipt_hash).collect();
    let proof = build_inclusion_proof(&next_roots, 1).unwrap();
    assert_eq!(
        proof.leaf_hash,
        "70cd9dc55d5eb8e95d7678e9e63850bf6eab82e4c8320bd921189cf33650a6dd"
    );
    assert_eq!(proof.peak_index, 0);
    assert_eq!(proof.peak_height, 4);
    assert_eq!(proof.path.len(), 4);
    assert!(verify_inclusion_proof(&proof));
}

#[test]
fn mmr_inclusion_proof_idx_2_matches_python() {
    let next_roots: Vec<String> = (1..=17).map(receipt_hash).collect();
    let proof = build_inclusion_proof(&next_roots, 2).unwrap();
    assert_eq!(
        proof.leaf_hash,
        "92f8fcff2113db0203a7c8a5fab996979cc75acb286f05888b80913a4046426c"
    );
    assert_eq!(proof.peak_index, 0);
    assert_eq!(proof.peak_height, 4);
    assert_eq!(proof.path.len(), 4);
    assert!(verify_inclusion_proof(&proof));
}

#[test]
fn mmr_inclusion_proof_idx_7_matches_python() {
    let next_roots: Vec<String> = (1..=17).map(receipt_hash).collect();
    let proof = build_inclusion_proof(&next_roots, 7).unwrap();
    assert_eq!(
        proof.leaf_hash,
        "a5e5d19866a9d0eb6f89e7a2c3564108df676da03915882e1fea97e614ffc840"
    );
    assert_eq!(proof.peak_index, 0);
    assert_eq!(proof.peak_height, 4);
    assert_eq!(proof.path.len(), 4);
    assert!(verify_inclusion_proof(&proof));
}

#[test]
fn mmr_inclusion_proof_idx_8_matches_python() {
    let next_roots: Vec<String> = (1..=17).map(receipt_hash).collect();
    let proof = build_inclusion_proof(&next_roots, 8).unwrap();
    assert_eq!(
        proof.leaf_hash,
        "630a05d2cd6d9976d6c0ae5d2a174882a955fd6dd453e05910234c5ccc77e8ea"
    );
    assert_eq!(proof.peak_index, 0);
    assert_eq!(proof.peak_height, 4);
    assert_eq!(proof.path.len(), 4);
    assert!(verify_inclusion_proof(&proof));
}

#[test]
fn mmr_inclusion_proof_idx_16_singleton_matches_python() {
    let next_roots: Vec<String> = (1..=17).map(receipt_hash).collect();
    let proof = build_inclusion_proof(&next_roots, 16).unwrap();
    assert_eq!(
        proof.leaf_hash,
        "2ba384ee5925e4ff8953fd5a59583c8fbff6fdf2f06ee056b6fae639ff1b66eb"
    );
    assert_eq!(proof.peak_index, 1);
    assert_eq!(proof.peak_height, 0);
    assert_eq!(proof.path.len(), 0);
    assert!(verify_inclusion_proof(&proof));
}

// ===========================================================================
// SECTION 4: MMR Tamper Detection
// ===========================================================================

/// Verify that tampered proofs fail verification — matching Python behavior.
#[test]
fn mmr_tampered_proof_fails_verification() {
    let next_roots: Vec<String> = (1..=9).map(receipt_hash).collect();
    let proof = build_inclusion_proof(&next_roots, 3).unwrap();
    assert!(verify_inclusion_proof(&proof));

    // Tamper with a sibling hash.
    let mut tampered = proof.clone();
    if !tampered.path.is_empty() {
        tampered.path[0].hash = "00".repeat(32);
    }
    assert!(!verify_inclusion_proof(&tampered));
}

/// Verify that modifying the receipt_next_root field invalidates the proof.
#[test]
fn mmr_tampered_receipt_root_fails_verification() {
    let next_roots: Vec<String> = (1..=9).map(receipt_hash).collect();
    let proof = build_inclusion_proof(&next_roots, 0).unwrap();
    assert!(verify_inclusion_proof(&proof));

    let mut tampered = proof.clone();
    tampered.receipt_next_root = "ff".repeat(32);
    assert!(!verify_inclusion_proof(&tampered));
}

// ===========================================================================
// SECTION 5: MMR Incremental Append — matches full rebuild
// ===========================================================================

/// Verify that incrementally appending leaves produces the same peaks as
/// building from scratch.
#[test]
fn mmr_incremental_append_matches_full_rebuild() {
    let next_roots: Vec<String> = (1..=10).map(receipt_hash).collect();

    let all_leaf_hashes: Vec<String> = next_roots
        .iter()
        .map(|nr| mmr_leaf_hash(nr).unwrap())
        .collect();
    let full_peaks = build_peaks(&all_leaf_hashes).unwrap();
    let full_root = bag_peaks(&full_peaks).unwrap();

    // Build incrementally: first 5, then next 5.
    let first5: Vec<String> = all_leaf_hashes[..5].to_vec();
    let rest5: Vec<String> = all_leaf_hashes[5..].to_vec();
    let peaks5 = build_peaks(&first5).unwrap();
    let inc_peaks = mez_crypto::mmr::append_peaks(&peaks5, &rest5).unwrap();
    let inc_root = bag_peaks(&inc_peaks).unwrap();

    assert_eq!(full_peaks, inc_peaks);
    assert_eq!(full_root, inc_root);
}

// ===========================================================================
// SECTION 6: Stateful MMR — matches functional API
// ===========================================================================

/// Verify that the stateful `MerkleMountainRange` struct produces identical
/// results to the functional API.
#[test]
fn stateful_mmr_matches_functional_api() {
    let next_roots: Vec<String> = (1..=17).map(receipt_hash).collect();
    let info = mmr_root_from_next_roots(&next_roots).unwrap();

    let mut mmr = MerkleMountainRange::new();
    for nr in &next_roots {
        mmr.append(nr).unwrap();
    }

    assert_eq!(mmr.size(), 17);
    assert_eq!(mmr.root().unwrap(), info.root);
    assert_eq!(mmr.peaks().len(), info.peaks.len());
    for (a, b) in mmr.peaks().iter().zip(info.peaks.iter()) {
        assert_eq!(a, b);
    }
}

// ===========================================================================
// SECTION 7: CAS Digest Computation — matches Python
// ===========================================================================

/// Verify that `ContentAddressedStore::store()` computes the same digest as
/// Python's `hashlib.sha256(jcs_canonicalize(data)).hexdigest()`.
#[test]
fn cas_digest_matches_python_transfer() {
    // Python: jcs_canonicalize({"action": "transfer", "amount": 1000})
    // → sha256 → "731e3a34c657ef9aa71674c0c69e890263b1df3b145a0d2685d6fea7095eb7b0"
    let data = json!({"action": "transfer", "amount": 1000});
    let canonical = CanonicalBytes::new(&data).unwrap();
    let digest = sha256_digest(&canonical);
    assert_eq!(
        digest.to_hex(),
        "731e3a34c657ef9aa71674c0c69e890263b1df3b145a0d2685d6fea7095eb7b0"
    );
}

#[test]
fn cas_digest_matches_python_key_value() {
    // Python: jcs_canonicalize({"key": "value"}) → sha256
    let data = json!({"key": "value"});
    let canonical = CanonicalBytes::new(&data).unwrap();
    let digest = sha256_digest(&canonical);
    assert_eq!(
        digest.to_hex(),
        "e43abcf3375244839c012f9633f95862d232a95b00d5bc7348b3098b9fed7f32"
    );
}

#[test]
fn cas_digest_matches_python_important_data() {
    // Python: jcs_canonicalize({"important": "data"}) → sha256
    let data = json!({"important": "data"});
    let canonical = CanonicalBytes::new(&data).unwrap();
    let digest = sha256_digest(&canonical);
    assert_eq!(
        digest.to_hex(),
        "3b6f5b0655f4bab49009f9c60367769a3d67ad7ea3dbd6ae79c24447b1951b93"
    );
}

// ===========================================================================
// SECTION 8: CAS Store/Resolve Roundtrip with Python Digest
// ===========================================================================

/// Verify that storing data via CAS produces files at the correct
/// content-addressed path with Python-compatible digests.
#[test]
fn cas_store_produces_python_compatible_path() {
    let dir = tempfile::tempdir().unwrap();
    let cas = mez_crypto::ContentAddressedStore::new(dir.path());

    let data = json!({"action": "transfer", "amount": 1000});
    let artifact_ref = cas.store("receipt", &data).unwrap();

    // Digest must match Python's computation.
    assert_eq!(
        artifact_ref.digest.to_hex(),
        "731e3a34c657ef9aa71674c0c69e890263b1df3b145a0d2685d6fea7095eb7b0"
    );

    // File must exist at the expected path.
    let expected_path = dir
        .path()
        .join("receipt")
        .join("731e3a34c657ef9aa71674c0c69e890263b1df3b145a0d2685d6fea7095eb7b0.json");
    assert!(expected_path.exists());

    // Resolve must return the same data.
    let resolved = cas.resolve("receipt", &artifact_ref.digest).unwrap();
    assert!(resolved.is_some());
}

// ===========================================================================
// SECTION 9: Ed25519 — CanonicalBytes Enforcement
// ===========================================================================

/// Verify that Ed25519 signing uses CanonicalBytes, producing deterministic
/// signatures for identical data regardless of input key ordering.
#[test]
fn ed25519_signing_is_canonical_order_independent() {
    use mez_crypto::SigningKey;
    use rand_core::OsRng;

    let sk = SigningKey::generate(&mut OsRng);
    let vk = sk.verifying_key();

    // Same logical data, different insertion order.
    let data_a = json!({"z": 1, "a": 2, "m": 3});
    let data_b = json!({"a": 2, "m": 3, "z": 1});

    let cb_a = CanonicalBytes::new(&data_a).unwrap();
    let cb_b = CanonicalBytes::new(&data_b).unwrap();

    // Canonical bytes must be identical (keys sorted).
    assert_eq!(cb_a, cb_b);

    let sig_a = sk.sign(&cb_a);
    let sig_b = sk.sign(&cb_b);

    // Signatures must be identical (deterministic Ed25519 over same bytes).
    assert_eq!(sig_a, sig_b);

    // Both must verify.
    assert!(vk.verify(&cb_a, &sig_a).is_ok());
    assert!(vk.verify(&cb_b, &sig_b).is_ok());
}

/// Verify that Ed25519 signatures are deterministic for the same key and data.
#[test]
fn ed25519_deterministic_across_invocations() {
    use mez_crypto::SigningKey;

    let key_bytes = [42u8; 32];
    let sk = SigningKey::from_bytes(&key_bytes);

    let data = json!({"corridor_id": "pk-ae", "sequence": 1});
    let cb = CanonicalBytes::new(&data).unwrap();

    let sig1 = sk.sign(&cb);
    let sig2 = sk.sign(&cb);
    assert_eq!(sig1, sig2);
}

// ===========================================================================
// SECTION 10: Leaf Hash and Node Hash — domain separation fixtures
// ===========================================================================

/// Verify domain-separated leaf hashing against Python fixtures.
#[test]
fn leaf_hash_domain_separation_matches_python() {
    // receipt-1 next_root
    let nr1 = "fea5396a7f4325c408b1b65b33a4d77ba5486ceba941804d8889a8546cfbab96";
    let lh1 = mmr_leaf_hash(nr1).unwrap();
    assert_eq!(
        lh1,
        "29534994a3ad2af6dd418f46d4093897971cd14bea312167ad82c4b31dbbfcec"
    );

    // receipt-2 next_root
    let nr2 = "774ad7ab1a3d41b114b5f4a34e2d8fc19c2ee8d83dfc133f1d80068ed205597f";
    let lh2 = mmr_leaf_hash(nr2).unwrap();
    assert_eq!(
        lh2,
        "70cd9dc55d5eb8e95d7678e9e63850bf6eab82e4c8320bd921189cf33650a6dd"
    );
}

/// Verify domain-separated node hashing against Python fixtures.
#[test]
fn node_hash_domain_separation_matches_python() {
    let lh1 = "29534994a3ad2af6dd418f46d4093897971cd14bea312167ad82c4b31dbbfcec";
    let lh2 = "70cd9dc55d5eb8e95d7678e9e63850bf6eab82e4c8320bd921189cf33650a6dd";
    let nh = mmr_node_hash(lh1, lh2).unwrap();
    assert_eq!(
        nh,
        "a34e6d5dac1ff07f820cc5156b41a50ce78c6a6868d81d5c5824cad0cab7250b"
    );
}

// ===========================================================================
// SECTION 11: Next-root hash computation — SHA256("receipt-N") fixtures
// ===========================================================================

/// Verify that our SHA256 computation of receipt strings matches Python.
#[test]
fn receipt_next_root_hashes_match_python() {
    let expected = [
        (
            1,
            "fea5396a7f4325c408b1b65b33a4d77ba5486ceba941804d8889a8546cfbab96",
        ),
        (
            2,
            "774ad7ab1a3d41b114b5f4a34e2d8fc19c2ee8d83dfc133f1d80068ed205597f",
        ),
        (
            3,
            "de84f16f82e8cf8c184f7883460865481ba6f1fa5b48c3ae4e75b9e9786a6b03",
        ),
        (
            4,
            "9bf922d8ee39a15df6c2b0081aa0f508601a13287fc31a902aa34eccbf835def",
        ),
        (
            5,
            "9f11d91831441bd7245531a84f92a4e1a7a2e2ab7b67786351f077a4fd10efea",
        ),
        (
            9,
            "e6fdb34dc858fdc85c667742163c42a257b8eaefab62c6c7138d2da4aa4344d2",
        ),
        (
            16,
            "4ce306d785e156ecce175d1c1693c2c72599eed1ce7e90dfcca7214e65ef2446",
        ),
        (
            17,
            "3d9b849244959f3c63eab896d824a077a145676a6205fb17b3d23df3a3f560b6",
        ),
    ];

    for (i, expected_hex) in expected {
        let actual = receipt_hash(i);
        assert_eq!(actual, expected_hex, "SHA256(\"receipt-{i}\") mismatch");
    }
}

// ===========================================================================
// SECTION 12: Full receipt sequence — all 17 next_root hashes
// ===========================================================================

/// Verify all 17 next_root hashes match the complete Python fixture set.
#[test]
fn all_17_next_roots_match_python() {
    let expected_next_roots = [
        "fea5396a7f4325c408b1b65b33a4d77ba5486ceba941804d8889a8546cfbab96",
        "774ad7ab1a3d41b114b5f4a34e2d8fc19c2ee8d83dfc133f1d80068ed205597f",
        "de84f16f82e8cf8c184f7883460865481ba6f1fa5b48c3ae4e75b9e9786a6b03",
        "9bf922d8ee39a15df6c2b0081aa0f508601a13287fc31a902aa34eccbf835def",
        "9f11d91831441bd7245531a84f92a4e1a7a2e2ab7b67786351f077a4fd10efea",
        "1f88814ff1d5f5300396ba391fd12fc9e46cea4f68d1e70b3b219ab3dbcd480c",
        "b9e8be61a195415d90f6453066a979ea13b30499b622f707ee5dbbe1ed58294a",
        "eb75bd2e1c056b3ffc82bab6e9d09051e2547f2046baa7b62056e0c0a07fa1dd",
        "e6fdb34dc858fdc85c667742163c42a257b8eaefab62c6c7138d2da4aa4344d2",
        "a40b8ea6c3bfbe2a58cd15f870bd261297d1604b78bbb299b4b62afdb3fb2897",
        "651e9f306453649cf1b3be1c468868c31f953a6268144f93a2f83e41ac48b77f",
        "e90d497520fcfaa2c133d711f989d877eb7cfd8b57c10f8f91520fed45fcb849",
        "63e81058f8e39f0b6551e2876b87c8cac05df6a6b3888f3fa18858c11b48a349",
        "b27e6eebf85812aa8d6bb982bd60fe21acdee1dd1252e3a02bff48e7d11be237",
        "83a00529fc37dea7e5fc90663041498d12447ba74524368dc2d8026406024528",
        "4ce306d785e156ecce175d1c1693c2c72599eed1ce7e90dfcca7214e65ef2446",
        "3d9b849244959f3c63eab896d824a077a145676a6205fb17b3d23df3a3f560b6",
    ];

    let rust_next_roots: Vec<String> = (1..=17).map(receipt_hash).collect();
    for (i, (expected, actual)) in expected_next_roots
        .iter()
        .zip(rust_next_roots.iter())
        .enumerate()
    {
        assert_eq!(expected, actual, "next_root mismatch at receipt-{}", i + 1);
    }
}
