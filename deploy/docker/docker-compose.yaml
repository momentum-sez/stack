# MEZ Stack — Docker Compose (Rust Binary Architecture)
#
# Replaces the previous 12-service Python-based compose that referenced
# non-existent `serve` subcommands. The Rust architecture consolidates
# all five primitive API services into a single mez-api binary (Axum),
# with PostgreSQL for persistence and Prometheus/Grafana for observability.
#
# Previous setup: 9 Python services (zone-authority, entity-registry,
#   license-registry, corridor-node, watcher, identity-service,
#   settlement-service, compliance-service, regulator-console) — none
#   of which could start because the `serve` CLI subcommands did not exist.
#
# Current setup: 1 Rust API server exposing all endpoints on port 8080,
#   with PostgreSQL, Prometheus, and Grafana as supporting infrastructure.
#
# Usage:
#   docker compose up -d                           # Start all services
#   docker compose logs -f mez-api                # Follow API logs
#   docker compose exec mez-api mez-cli validate --all-modules  # Run validation
#   docker compose down                            # Stop all services
#   docker compose down -v                         # Stop and remove volumes

name: mez-zone

services:
  # ============================================
  # APPLICATION
  # ============================================

  # mez-api: Axum HTTP server serving all five primitive APIs
  # (Entities, Ownership, Fiscal, Identity, Consent), corridor operations,
  # smart asset CRUD, compliance evaluation, and regulator console.
  mez-api:
    build:
      context: ../..
      dockerfile: deploy/docker/Dockerfile
    container_name: mez-api
    restart: unless-stopped
    ports:
      - "8080:8080"
    environment:
      # Zone configuration
      MEZ_ZONE_ID: ${MEZ_ZONE_ID:-org.momentum.mez.zone.local}
      MEZ_JURISDICTION: ${MEZ_JURISDICTION:-ex}
      MEZ_PROFILE: ${MEZ_PROFILE:-digital-financial-center}
      # Zone manifest — set to load jurisdiction-specific configuration
      ZONE_CONFIG: ${ZONE_CONFIG:-}
      # Zone signing key — 32-byte hex from Ed25519 JWK private key
      ZONE_SIGNING_KEY_HEX: ${ZONE_SIGNING_KEY_HEX:-}
      # Server
      MEZ_HOST: "0.0.0.0"
      MEZ_PORT: "8080"
      MEZ_LOG_LEVEL: ${MEZ_LOG_LEVEL:-info}
      # Authentication
      AUTH_TOKEN: ${AUTH_TOKEN:-}
      # Database (PostgreSQL via SQLx)
      DATABASE_URL: "postgresql://mez:${POSTGRES_PASSWORD:?POSTGRES_PASSWORD must be set}@postgres:5432/mez"
      # Corridor configuration
      MEZ_CORRIDOR_ID: ${MEZ_CORRIDOR_ID:-org.momentum.mez.corridor.swift.iso20022-cross-border}
      # Watcher configuration
      MEZ_WATCHER_ID: ${MEZ_WATCHER_ID:-watcher-local-001}
      MEZ_BOND_AMOUNT: ${MEZ_BOND_AMOUNT:-100000}
      # Mass API configuration
      MASS_API_TOKEN: ${MASS_API_TOKEN:-}
      MASS_ORG_INFO_URL: ${MASS_ORG_INFO_URL:-https://organization-info.api.mass.inc}
      MASS_TREASURY_INFO_URL: ${MASS_TREASURY_INFO_URL:-https://treasury-info.api.mass.inc}
      MASS_CONSENT_INFO_URL: ${MASS_CONSENT_INFO_URL:-https://consent.api.mass.inc}
      MASS_IDENTITY_INFO_URL: ${MASS_IDENTITY_INFO_URL:-}
      MASS_TIMEOUT_SECS: ${MASS_TIMEOUT_SECS:-30}
      # Metrics
      MEZ_METRICS_ENABLED: "true"
    volumes:
      - api-data:/app/data
      - api-config:/app/config
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - mez-internal
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health/liveness"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 15s

  # ============================================
  # DATABASE
  # ============================================

  # PostgreSQL 16 — primary data store
  # Schema initialized via init-db.sql; runtime migrations via SQLx.
  postgres:
    image: postgres:16-alpine
    container_name: mez-postgres
    restart: unless-stopped
    environment:
      POSTGRES_USER: mez
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:?POSTGRES_PASSWORD must be set}
      POSTGRES_DB: mez
    volumes:
      - postgres-data:/var/lib/postgresql/data
      - ./init-db.sql:/docker-entrypoint-initdb.d/01-init.sql:ro
    ports:
      - "5432:5432"
    networks:
      - mez-internal
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U mez -d mez"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 10s

  # ============================================
  # OBSERVABILITY
  # ============================================

  # Prometheus — metrics collection from mez-api /metrics endpoint
  prometheus:
    image: prom/prometheus:v2.51.0
    container_name: mez-prometheus
    restart: unless-stopped
    volumes:
      - ./prometheus.yaml:/etc/prometheus/prometheus.yml:ro
      - prometheus-data:/prometheus
    ports:
      - "9090:9090"
    networks:
      - mez-internal
    depends_on:
      - mez-api
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--storage.tsdb.retention.time=30d'
      - '--web.enable-lifecycle'

  # Grafana — metrics visualization
  grafana:
    image: grafana/grafana:10.4.1
    container_name: mez-grafana
    restart: unless-stopped
    environment:
      GF_SECURITY_ADMIN_USER: admin
      GF_SECURITY_ADMIN_PASSWORD: ${GRAFANA_PASSWORD:?GRAFANA_PASSWORD must be set}
      GF_USERS_ALLOW_SIGN_UP: "false"
    volumes:
      - grafana-data:/var/lib/grafana
      - ./grafana/provisioning:/etc/grafana/provisioning:ro
      - ./grafana/dashboards:/var/lib/grafana/dashboards:ro
    ports:
      - "3000:3000"
    networks:
      - mez-internal
    depends_on:
      - prometheus

# ============================================
# NETWORKS
# ============================================

networks:
  mez-internal:
    driver: bridge
    name: mez-internal

# ============================================
# VOLUMES
# ============================================

volumes:
  api-data:
  api-config:
  postgres-data:
  prometheus-data:
  grafana-data:
