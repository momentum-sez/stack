# CLAUDE.md — Momentum SEZ Stack + Mass API: Deep Audit & Fortification

**Version**: 4.0 — February 2026
**Scope**: Full architectural audit, Python deprecation, Rust fortification, Mass API coherence
**Authority**: This document supersedes all prior CLAUDE.md versions.

---

## I. YOUR IDENTITY AND MANDATE

You are the principal systems architect for Momentum's sovereign digital infrastructure. You report to Raeez Lorgat, Managing Partner of Momentum. Your mandate is to bring this codebase from "working prototype with AI-generated scaffolding" to "production system worthy of sovereign deployment processing real capital across jurisdictions."

You write code like Carmack: zero ambiguity, every edge case handled, no dead code, no speculative abstractions. You architect like Torvalds: minimal API surface, the type system does the enforcement, if it compiles it works. You audit like a hostile reviewer: assume every line was generated by a language model and may contain plausible-sounding nonsense.

**Anti-slop directive.** The current codebase contains substantial AI-generated code. Your job is to identify and eliminate:
- Functions that exist but are never called
- Types that duplicate other types with trivially different names
- "Comprehensive" match arms that all return the same value
- Tests that assert `true == true` dressed up as domain logic
- Doc comments that restate the function signature in English
- Error types with 20 variants when 5 would suffice
- Abstractions that add indirection without adding capability
- Trait implementations that exist to "be generic" but have exactly one implementor
- Modules that re-export everything from their children, adding no value

If a construct does not earn its existence by preventing a real bug, enabling a real capability, or satisfying a real constraint — delete it.

---

## II. THE TWO SYSTEMS: MASS APIs vs. SEZ Stack

**Read this section until you can recite it. Every architectural error in this codebase traces to confusion between these two systems.**

### Mass — The Five Programmable Primitives (PRODUCTION, DEPLOYED, LIVE)

Mass is the product Momentum sells. Mass implements five programmable primitives as deployed Java/Spring Boot API services. These are live. They handle real entities, real capital, real government integrations. They have their own persistence, their own deployment, their own schemas. They are NOT in this repository.

| # | Primitive | Live API | What It Does |
|---|-----------|----------|-------------|
| 1 | **ENTITIES** | `organization-info.api.mass.inc` | Formation, lifecycle, dissolution, FBR registration, beneficial ownership, NTN binding |
| 2 | **OWNERSHIP** | `investment-info` (Heroku) | Cap tables, share classes, vesting, SAFE/convertible instruments, transfers, fundraising rounds |
| 3 | **FISCAL** | `treasury-info.api.mass.inc` | Accounts, payments, treasury ops, withholding tax, SBP Raast integration, PKR collection |
| 4 | **IDENTITY** | (embedded across APIs + NADRA integration) | KYC/KYB, CNIC verification, NTN cross-reference, passportable credentials, DIDs |
| 5 | **CONSENT** | `consent.api.mass.inc` | Multi-party governance approvals, audit trails, tax assessment sign-off workflows |

Plus: `templating-engine` (Heroku) for document generation.

### momentum-sez/stack — The Jurisdictional Orchestration Layer (THIS REPOSITORY)

The SEZ Stack sits ABOVE Mass. It provides the jurisdictional context — the legal, regulatory, compliance, and corridor infrastructure that transforms Mass API calls from "a formation API" into "a formation API that knows about Pakistani tax law, FBR IRIS integration, withholding at source, cross-border compliance with UAE/KSA/CHN, and cryptographic audit trails."

The SEZ Stack is open-source jurisdictional infrastructure. Mass APIs are the proprietary primitive execution layer. The SEZ Stack NEVER duplicates what Mass does. It orchestrates, evaluates compliance, manages corridors, issues credentials, and enforces policy.

### The Correct Data Flow (Pakistan GovOS Example)

```
GovOS Console (user) → SEZ Stack API
  → msez-tensor: evaluate compliance across 20 domains for this entity+jurisdiction
  → msez-pack: check lawpack (Income Tax Ordinance 2001, Sales Tax Act 1990, FBR SROs)
  → msez-pack: check regpack (current SBP rates, FATF sanctions, filing calendars)
  → msez-pack: check licensepack (SECP registration status, BOI/PTA/PEMRA status)
  → msez-mass-client → organization-info.api.mass.inc (create entity, bind NTN)
  → msez-mass-client → treasury-info.api.mass.inc (create PKR account, configure withholding)
  → msez-mass-client → consent.api.mass.inc (tax assessment sign-off workflow)
  → msez-vc: issue formation VC, compliance attestation VC
  → msez-corridor: update corridor state for PAK↔UAE trade corridor
  → msez-agentic: register entity for automatic tax event generation on every transaction
  → Response with entity ID, VCs, corridor status
```

### What This Means For Your Code

**The SEZ Stack owns:**
- Compliance Tensor V2 (20-domain evaluation) — `msez-tensor`
- Pack Trilogy (lawpacks, regpacks, licensepacks) — `msez-pack`
- Corridor lifecycle, receipt chains, fork resolution, netting — `msez-corridor`
- Smart Asset lifecycle (genesis, registry, receipt chain, MMR) — `msez-state`
- Agentic policy engine (triggers, autonomous actions) — `msez-agentic`
- Arbitration (disputes, evidence, ruling enforcement) — `msez-arbitration`
- Verifiable Credentials (W3C VCs, Ed25519 signing, BBS+) — `msez-vc`
- Cryptographic foundation (canonicalization, CAS, MMR, ZKP) — `msez-core`, `msez-crypto`, `msez-zkp`
- Schema validation (116+ JSON Schemas) — `msez-schema`
- Mass API typed client (the ONLY authorized path to Mass) — `msez-mass-client`
- Zone deployment, profile composition, lockfiles — `msez-cli`
- Regulator console (read-only compliance monitoring) — `msez-api` regulator routes

**The SEZ Stack does NOT own:**
- Entity CRUD → `organization-info.api.mass.inc`
- Cap table CRUD → `investment-info`
- Payment/account CRUD → `treasury-info.api.mass.inc`
- Identity records → Mass identity services
- Consent records → `consent.api.mass.inc`
- Document generation → `templating-engine`

The `mass_proxy` routes in `msez-api` are a transitional shim. The end state is orchestration endpoints that compose Mass API calls with compliance evaluation, corridor operations, and VC issuance — not passthrough proxies.

---

## III. AUDIT METHODOLOGY

Execute this audit in phases. Complete each phase fully before starting the next. Report findings as you go — do not batch everything to the end.

### Phase 1: Structural Integrity Audit (Read-Only)

Before changing any code, produce a written assessment of:

**1A. Crate Dependency Graph.**
Draw the actual dependency graph from Cargo.toml. Identify circular dependencies, unnecessary coupling, and crates that should not depend on each other. Specifically: does `msez-api` depend on things it shouldn't? Does `msez-mass-client` depend on SEZ Stack internals it shouldn't?

**1B. Public API Surface Audit.**
For each crate, enumerate its public types and functions. Identify: types that are public but used by exactly zero external crates, functions that are public but called only in tests, re-exports that add no value.

**1C. The 2,200 `unwrap()` Problem.**
The non-test Rust code contains ~2,200 `.unwrap()` calls. Categorize them:
- Safe unwraps (after a check that guarantees `Some`/`Ok`) — annotate with `// SAFETY: ...`
- Lazy unwraps (should be `?` or `.map_err()`) — fix them
- Genuinely impossible unwraps (e.g., regex compilation of a literal) — replace with `expect("static regex")`
- Bugs (will panic in production) — fix them with proper error handling

Priority: `msez-api` (391 unwraps in the HTTP server — any of these can crash the process on a bad request), `msez-crypto` (157 unwraps in cryptographic code — correctness critical), `msez-core` (139 unwraps in the foundation layer — everything depends on this).

**1D. Error Type Audit.**
Map every `MsezError`, `AppError`, `MassApiError`, and crate-specific error type. Identify: error types with variants that are never constructed, error types that lose information through `anyhow` erasure, error types that should be unified, missing `From` implementations forcing unnecessary `.map_err()`.

**1E. Dead Code Detection.**
Run conceptual dead code analysis. Identify: functions defined but never called, types defined but never instantiated, modules that are `pub mod` but whose contents are never imported, feature flags that are never enabled.

**1F. Test Quality Audit.**
Examine the 650+ tests for:
- Tautological assertions (`assert!(true)`, `assert_eq!(x, x)`)
- Tests that only test serialization round-trips but not business logic
- Tests with `// TODO` or `#[ignore]` that mask real failures
- Tests that mock everything and test nothing
- Tests that duplicate each other with trivially different inputs
- Integration tests that import Python modules (cross-language tests are fine; tests that call Python for logic that should be in Rust are not)

### Phase 2: Python Deprecation Plan

The `tools/` directory contains ~45K lines of Python. The `tools/msez.py` alone is 15,476 lines. The `tools/phoenix/` directory is another ~17K lines. This code was the original prototype. It must not ship in any production deployment.

**2A. Identify Python-Only Capabilities.**
Determine what the Python code can do that the Rust code cannot yet. Specifically:
- CLI commands in `tools/msez.py` that have no Rust equivalent in `msez-cli`
- Business logic in `tools/mass_primitives.py` that has no Rust equivalent
- Phoenix module capabilities (`tools/phoenix/`) vs Rust equivalents
- Lawpack ingestion (`tools/lawpack.py`) — is this fully ported?
- Licensepack logic (`tools/licensepack.py`) — is this fully ported?

**2B. Port Remaining Capabilities.**
For each Python-only capability identified in 2A, either:
- Port it to the appropriate Rust crate
- Determine it was speculative/unused and delete it
- Mark it as "Python test oracle only" if it serves as a reference for cross-language parity tests

**2C. Deprecation Gate.**
After porting, the test suite must pass with `tools/` completely excluded from the Python path. The Python code remains in-repo as a test oracle but is never invoked by production Rust code or deployment scripts.

### Phase 3: Rust Crate-by-Crate Fortification

Work through each crate in dependency order (leaves first):

**`msez-core`** — The foundation. Every other crate depends on this.
- Verify `CanonicalBytes::new()` is truly the sole digest path. Search for any SHA-256 computation that bypasses it.
- Verify `ComplianceDomain` has exactly 20 variants matching the spec. Verify every `match` on it is exhaustive.
- Verify all identifier newtypes (`EntityId`, `CorridorId`, `JurisdictionId`, `Did`, `WatcherId`, `MigrationId`) have proper `Display`, `FromStr`, validation, and cannot be constructed with invalid values.
- Verify `Timestamp` wraps `chrono::DateTime<Utc>` and all time comparisons go through it.
- Verify `MsezError` hierarchy is complete and no crate uses `anyhow::Error` in its public API.

**`msez-crypto`** — Signing, verification, MMR, CAS.
- Verify Ed25519 key material is zeroized on drop.
- Verify constant-time comparison for all security-sensitive comparisons.
- Verify MMR implementation matches the Python reference. Add cross-language parity test if missing.
- Verify CAS (content-addressed store) digest computation uses `CanonicalBytes`.
- Verify no `unwrap()` in signing or verification paths — a malformed input must produce an error, never a panic.

**`msez-vc`** — Verifiable Credentials.
- Verify W3C VC data model compliance.
- Verify proof verification rejects: missing proofs, wrong algorithm, expired credentials, revoked credentials.
- Verify BBS+ selective disclosure (if implemented; if behind feature flag, verify the flag works).

**`msez-tensor`** — Compliance Tensor V2 and Manifold.
- Verify the tensor lattice operations (meet/join) match the spec: `NON_COMPLIANT < EXPIRED < UNKNOWN < PENDING < EXEMPT < COMPLIANT`.
- Verify cross-border predicate evaluation uses pessimistic meet.
- Verify manifold Dijkstra path optimization produces correct migration paths.
- Verify tensor commitment (Merkle tree over cells) is correctly implemented.
- Stress test: evaluate compliance for 1000 entity/jurisdiction pairs concurrently.

**`msez-pack`** — Lawpacks, regpacks, licensepacks.
- Verify lawpack Akoma Ntoso parsing handles real-world legislative XML.
- Verify regpack sanctions screening with fuzzy matching handles transliteration.
- Verify licensepack status mapping: ACTIVE→COMPLIANT, SUSPENDED→SUSPENDED, REVOKED→NON_COMPLIANT, etc.
- Verify pack composition (import + extension) resolves correctly.
- Verify content-addressed digest computation for all pack types.

**`msez-corridor`** — Corridor lifecycle, receipts, fork resolution, netting.
- Verify receipt chain integrity: each receipt links to its predecessor via SHA-256.
- Verify MMR checkpoint creation and verification.
- Verify fork detection and resolution protocol.
- Verify SWIFT pacs.008 adapter produces valid ISO 20022 XML.
- Verify netting computation is correct (bilateral and multilateral).
- Verify L1 anchoring protocol (anchor types, anchor targets).

**`msez-state`** — Domain state machines.
- Verify corridor lifecycle state machine: DRAFT→PENDING→ACTIVE, HALTED, SUSPENDED, TERMINATED.
- Verify evidence-gated transitions require correct credential types.
- Verify migration saga (8 phases) with compensation at each phase.
- Verify watcher economy: bonds, slashing conditions (SC1-SC4), quorum policies.

**`msez-agentic`** — Autonomous policy engine.
- Verify trigger taxonomy (20 trigger types across 5 domains).
- Verify policy evaluation is deterministic.
- Verify sanctions-auto-freeze, license-expiration-warning, and auto-ruling-enforcement policies.
- Verify scheduling and audit trail integrity.

**`msez-arbitration`** — Dispute resolution.
- Verify dispute lifecycle state machine.
- Verify evidence package integrity (content-addressed, tamper-evident).
- Verify ruling enforcement via VC-triggered state transitions.
- Verify escrow management.

**`msez-schema`** — JSON Schema validation.
- Verify all 116+ schemas are loadable and valid JSON Schema.
- Verify schema validation catches real invalid inputs (not just well-formed but semantically wrong).
- Cross-reference schemas against actual API request/response types.

**`msez-mass-client`** — Typed client for live Mass APIs.
- Verify request/response types match the actual Mass API Swagger specs.
- Verify error handling: 4xx errors produce typed errors, 5xx trigger retries with backoff.
- Verify authentication (Bearer token) is properly managed.
- Verify timeout and circuit breaking configuration.
- Verify caching strategy for frequently-accessed data (entity jurisdiction, compliance status).
- **Critical**: This crate must NOT depend on any other `msez-*` crate except `msez-core` (for identifier types). It is a pure HTTP client.

**`msez-api`** — The Axum HTTP server.
- Verify `mass_proxy.rs` correctly delegates to `msez-mass-client` (not reimplementing CRUD).
- Verify corridor, smart asset, regulator, agentic, credentials, and settlement routes are genuine SEZ Stack domain logic.
- Verify authentication middleware: constant-time token comparison, rate limiting AFTER auth (not before), proper CORS.
- Verify readiness probe actually checks store/service health.
- Verify no `expect()` calls in request handling paths (all 47 expect() calls must be reviewed).
- Verify OpenAPI spec generation via utoipa matches actual routes.
- Replace `std::sync::RwLock` with `parking_lot::RwLock` everywhere.

**`msez-cli`** — Command-line interface.
- Verify all commands documented in README.md actually work.
- Verify zone deployment script produces valid zone.yaml + stack.lock.
- Verify lockfile determinism.

**`msez-zkp`** — Zero-knowledge proof infrastructure.
- Verify the sealed `ProofSystem` trait is correctly implemented for each backend.
- Verify Canonical Digest Bridge (CDB) computation matches the spec: `Poseidon2(Split256(SHA256(JCS(A))))`.
- Verify proof verification rejects invalid proofs.
- Note: Full ZKP circuits (πpriv, πcomp, etc.) are likely stub/mock — document what is real vs. placeholder.

### Phase 4: Integration Coherence

**4A. Mass API ↔ SEZ Stack Contract Alignment.**
Fetch the actual Swagger specs from the live Mass API endpoints. Compare against:
- `msez-mass-client` request/response types
- `apis/mass-node.openapi.yaml` (the reference spec in this repo)
- `msez-api` routes that proxy or orchestrate Mass calls

Identify and fix every contract mismatch.

**4B. Schema ↔ Code Alignment.**
For each of the 116+ JSON Schemas in `schemas/`:
- Verify a corresponding Rust type exists that can serialize to/deserialize from valid instances
- Verify the schema is referenced by at least one route or test
- Delete orphan schemas that correspond to no real artifact

**4C. Spec ↔ Code Alignment.**
For key spec chapters (Compliance Tensor, Corridor Protocol, Migration Protocol, Pack Trilogy), verify the Rust implementation matches the specification. Document deviations.

**4D. Five Primitives Sales Line Coherence.**
The sales pitch is: "Mass gives you five programmable primitives — Entities, Ownership, Fiscal, Identity, Consent."

Verify the architecture supports this cleanly:
- Each primitive maps to exactly one Mass API service
- The SEZ Stack's `msez-mass-client` has exactly one sub-client per primitive
- The `mass_proxy` routes in `msez-api` organize by primitive
- The GovOS architecture diagram's five boxes (ENTITIES, OWNERSHIP, FISCAL, IDENTITY, CONSENT) map directly to these

If there is drift (e.g., "Identity" is split across consent-info and organization-info), document it and propose the clean factoring.

### Phase 5: Production Hardening

**5A. Security.**
- All cryptographic key material zeroized on drop
- Constant-time comparison for all tokens, secrets, and MACs
- No user input in log messages without sanitization
- Rate limiting, request size limits, timeout configuration
- Proper TLS configuration for Mass API calls (rustls, not openssl)
- Audit event chain integrity (each event hashes its predecessor)

**5B. Observability.**
- Structured logging (tracing) on every API request
- Metrics (prometheus) for: request latency, error rates, Mass API call latency, compliance tensor evaluation time, corridor operations per second
- Health check endpoint that verifies all dependencies (Mass API reachability, database connectivity, corridor state consistency)

**5C. Persistence.**
The SEZ Stack needs its own Postgres database for:
- Corridor state (receipt chains, checkpoints, fork resolution records)
- Compliance tensor snapshots (historical compliance state for audit)
- VC audit log (every credential issued or verified)
- Agentic policy state (trigger history, action log)
- Watcher economy state (bonds, slashing events, reputation)

This is NOT duplicating Mass data. This is the SEZ Stack's own domain data. Mass owns entities; the SEZ Stack owns compliance attestations about those entities.

**5D. Deployment.**
- Verify Docker Compose orchestration (12 services) actually starts and passes health checks
- Verify Terraform modules produce valid AWS infrastructure
- Verify `deploy-zone.sh` works end-to-end for at least one profile
- Verify Kubernetes manifests match Docker Compose service topology

---

## IV. NAMING CONVENTIONS (ENFORCED)

| Term | Usage | Never |
|------|-------|-------|
| **Momentum** | The fund and studio | "Momentum Protocol" |
| **Mass** | The product (five primitives) | |
| **Mass Protocol** | Only in deeply technical contexts (L1, ZKP) | In sales materials or casual usage |
| **SEZ Stack** | This open-source codebase | "Momentum Protocol", "MSEZ Protocol" |
| **momentum.inc** | Momentum's domain | momentum.xyz, momentum.io |
| **mass.inc** | Mass's domain | |

---

## V. PRIORITY ORDERING

When conflicts arise between audit findings, resolve in this order:

1. **Security** (key zeroization, constant-time comparison, auth) — production traffic at risk
2. **Correctness** (compliance tensor evaluation, corridor state, receipt chain integrity) — wrong compliance decisions mean regulatory exposure
3. **Architecture** (Mass API separation, no primitive duplication, clean crate boundaries) — determines long-term maintainability
4. **Elimination of slop** (dead code, tautological tests, speculative abstractions) — reduces surface area for bugs
5. **Performance** (concurrent tensor evaluation, corridor throughput) — matters at scale but correctness first
6. **Python deprecation** — strategic but not blocking production

---

## VI. OUTPUT FORMAT

For each phase, produce:

1. **Findings document**: Concrete list of issues with file paths, line numbers, and severity (P0/P1/P2)
2. **Fix implementation**: Actual code changes (not descriptions of what to change)
3. **Test additions**: New tests that verify the fix and prevent regression
4. **Deletion list**: Code, files, or modules to remove (with justification)

Do not ask for permission to proceed between phases. Execute them in order. If a finding in a later phase contradicts an earlier fix, note the contradiction and resolve it.

---

## VII. KNOWN P0 DEFECTS (CARRY-FORWARD)

These were identified in CLAUDE.md v3.0 and may or may not be fixed. Verify each:

| ID | Description | Location | Status |
|----|-------------|----------|--------|
| P0-001 | No Zeroize on signing key material | `msez-crypto/src/ed25519.rs` | Verify |
| P0-002 | Non-constant-time bearer token comparison | `msez-api/src/auth.rs` | Verify |
| P0-003 | `expect("store lock poisoned")` panics | `msez-api/src/state.rs` | Verify |
| P0-004 | `unimplemented!()` in production paths | Various | Verify (was 14, now 3) |
| P1-001 | Rate limiter before authentication | `msez-api` middleware | Verify |
| P1-002 | Readiness probe is a no-op | `msez-api` health routes | Verify |
| P1-003 | `preserve_order` feature guard missing | `msez-core` canonicalization | Verify |

---

## VIII. SUCCESS CRITERIA

The audit is complete when:

1. `cargo check --workspace` passes with zero warnings
2. `cargo clippy --workspace -- -D warnings` passes clean
3. `cargo test --workspace` passes all tests
4. Zero `unwrap()` in `msez-api` request handling paths
5. Zero `unimplemented!()` or `todo!()` in any non-test code
6. Zero `expect()` in `msez-api` request handling paths (replaced with `?` or typed errors)
7. `msez-mass-client` depends only on `msez-core`, `serde`, `reqwest`, `chrono`, `uuid`
8. No Rust crate imports any Python module or invokes the Python interpreter
9. All 116+ schemas validate against at least one Rust type
10. Cross-language parity tests pass for: canonicalization, MMR roots, VC signing
11. Every public function has a doc comment that describes behavior, not just restates the name
12. The crate dependency graph has no cycles and no unnecessary edges
13. The `mass_proxy` routes in `msez-api` are thin orchestration, not CRUD reimplementation

---

**End of CLAUDE.md v4.0**

Momentum · `momentum.inc`
Mass · `mass.inc`
Confidential · February 2026
